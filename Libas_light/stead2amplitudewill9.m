%==================================================================%%	stead2amplitude%% ermittelt fuer jede angegebene vp datenmatrix und% mittlere steady-state amplitude% sliding window procedure% ermittlung von amplitude in steady state daten	% matlab 4 erforderlich wegen yulewalk filterdesign%%Caution:psdvec = max-min - irrefuehrender Vektorname%%	%	Function definition function [tenHZamppsd, tenHZampfft, Difampvec, Phasevec, winmat, FourierCompVec] = stead2amplitudewill9(FilePath);disp('long baseline')exp = 'SSVEPatt'%===========================================================% 1. lese daten einer vp und bedingung ein, falls nicht angegeben%===========================================================if nargin < 1FilterSpec='*.at*'; FilePath=[]; [File,Path,FilePath]=ReadFilePath(FilePath,FilterSpec,['Averaged file:'],[],[],['Please choose the\n'],['averaged file to analyse:']);end[rawmat, File, Path] = Readavgfile(FilePath);%===========================================================%filtern%===========================================================%disp('filtering data')%filtmat=zeros(size(rawmat));%M=[0 1 1 0 0];%F=[0 0.004 0.2 0.2 1];%[B, A] = YULEWALK(9,F,M);%for nchan = 1 : 129;%   Y = FILTFILT(B, A, rawmat(nchan,:));%  filtmat(nchan,:) = Y;%end%%%%%% !!!!!!!filtmat = rawmat;%============================================================% 2. Baselinekorrektur%===========================================================disp ('subtracting baseline')dimrawfile = size (rawmat);datamat = zeros(size(rawmat));if exp == 'SSVEPatt', latms = 4000; end	% w- 4000%latms = input('insert onset latency/baseline length (ms!!)    ');latsp = latms/4;% marcus removed these% bslvec = mean(filtmat(:,[latsp/2:latsp])');%% % % for chan = 1 : 129;% 	% 	datamat(chan, :) = filtmat(chan,:) - bslvec(chan);%% % end	%datamat=filtmat;%===========================================================% 3. moving window procedure mit jeweils 5 zyklen (=500ms/125sp),% beginnend bei stimulusonset fuer alle kanaele. % shiften um 100ms (25sp) = 1 Zyklus%===========================================================disp('moving window procedure')winmatsum = zeros(129,125);for winshift = 0 : 25 : 1325 ; % shift nach baseline 101-1600        w - change	  -->  (2249-125)=		%disp(winshift)	for chan = 1:129		winmatsum(chan,:) = (winmatsum(chan,:) + regression(datamat(chan,[latsp+winshift:latsp+winshift+124]))');	% - w  	endendwinmat = winmatsum./54;						%   w -    ?  54  >  56   >   85%===========================================================% 3. detrending und demeaning der 5 verbleibenden zyklen:% berechne least squares regression fuer jeden kanal%===========================================================disp('demeaning of result')   	  for chan = 1:129;		  	      winmat(chan,:) = regression(winmat(chan,:))'; 	  end%===========================================================% 4. bestimmung der mittleren Amplitude fuer jeden Kanal mit psd/diff%===========================================================disp ('determining mean 10 Hz amplitude per channel')clear chanfor chan = 1 : 129;      psdvec = psd(winmat(chan,:));   tenHZamppsd(chan) = sqrt(psdvec(6,1));   tenHZamppsd(chan) = max(winmat(chan,:))-min(winmat(chan,:));end   %===========================================================% 5. bestimmung der mittleren Amplitude und Phase mit fft%===========================================================disp ('determining 10 Hz Phase per channel')clear chanfftMat = fft(winmat', 128);  % transpose: channels as columns (fft columnwise)     -128PowerMat = real(fftMat.*conj(fftMat)/128);			AmpMat = sqrt(PowerMat);tenHZampfft = AmpMat(6,:);PhaseMat = atan(real(fftMat)./imag(fftMat));Phasevec = PhaseMat(6,:);FourierCompVec = fftMat(6,:);%===========================================================% 6. bestimmung der mittleren Amplitude mit diffferenz(max-min)%===========================================================Difampvec = max(winmat')-min(winmat'); eval(['save ' Path 'winmat' FilePath(length(FilePath)-3) ' winmat -ascii'])% %  eval(['save ' Path '10Hzpower' FilePath(length(FilePath)-3) ' tenHZampfft -mat'])% %  eval(['save ' Path 'fourComp' FilePath(length(FilePath)-3) ' FourierCompVec -mat'])