%==================================================================%%	stead2amplitude%% ermittelt fuer jede angegebene vp datenmatrix und% mittlere steady-state amplitude% sliding window procedure% ermittlung von amplitude in steady state daten	% matlab 4 erforderlich wegen yulewalk filterdesign%%Caution:psdvec = max-min - irrefuehrender Vektorname%%	%	Function definition function [tenHZampfft_bslflick, Phasevec_bslflick, winmat_bslflick, FourierCompVec_bslflick, ...  tenHZampfft_letflick, Phasevec_letflick, winmat_letflick, FourierCompVec_letflick] = stead2ampLett(FilePath);exp_string = 'SSR_lett'%===========================================================% 1. lese daten einer vp und bedingung ein, falls nicht angegeben%===========================================================% if nargin<1;% %rawmat = Readavgfile; % alles einschl baseline einlesen - atg junhoeferfile% rawmat = read_avr_MEG(FilePath)% else rawmat = Readavgfile(FilePath);% endrawmat = Readavgfile(FilePath);%===========================================================%filtern%===========================================================%disp('filtering data')%filtmat=zeros(size(rawmat));%M=[0 1 1 0 0];%F=[0 0.004 0.2 0.2 1];%[B, A] = YULEWALK(9,F,M);%for nchan = 1 : 129;%   Y = FILTFILT(B, A, rawmat(nchan,:));%  filtmat(nchan,:) = Y;%end%%%%%% !!!!!!!filtmat = rawmat;%============================================================% 2. Baselinekorrektur%===========================================================disp ('subtracting baseline')dimrawfile = size (rawmat);datamat = zeros(size(rawmat));latms_bslflick = 1100; latms_letflick = 2540;%latms = input('insert onset latency/baseline length (ms!!)    ');latsp_bslflick = latms_bslflick/4;latsp_letflick = latms_letflick/4;% bslvec = mean(filtmat(:,[latsp/2:latsp])');% % % for chan = 1 : 129;% 	% 	datamat(chan, :) = filtmat(chan,:) - bslvec(chan);% % end	%===========================================================% 3. moving window procedure mit jeweils 5 zyklen (=500ms/125sp),% beginnend bei stimulusonset fuer alle kanaele. % shiften um 100ms (25sp) = 1 Zyklus%===========================================================disp('moving window procedure')winmatsum_bslflick = zeros(129,100);winmatsum_letflick = zeros(129,100);for winshift_bslflick = 0 : 20 :240  ; % 	winmatsum_bslflick = (winmatsum_bslflick + regressionMAT(filtmat(:,[latsp_bslflick+winshift_bslflick  :   latsp_bslflick+winshift_bslflick+99])));	winmat_bslflick = winmatsum_bslflick ./13;	%plot (winmatsum_bslflick')	endfor winshift_letflick = 0 : 20 :600  ; % 	winmatsum_letflick = (winmatsum_letflick + regressionMAT(filtmat(:,[latsp_letflick+winshift_letflick  :   latsp_letflick+winshift_letflick+99])));	winmat_letflick = winmatsum_letflick ./31;enddisp(latsp_bslflick+winshift_bslflick+99)%===========================================================% 3. detrending und demeaning der 5 verbleibenden zyklen:% berechne least squares regression fuer jeden kanal%===========================================================%disp('demeaning of result')      %	  for chan = 1:129;		  %	      winmat(chan,:) = winmat(chan,:) %	  end%save ubies:transport:winmatvor winmat -ascii%===========================================================% 4. bestimmung der mittleren Amplitude fuer jeden Kanal mit psd/diff%===========================================================disp ('determining mean 10 Hz amplitude per channel')clear chanfor chan = 1 : 129;      %psdvec = psd(winmat(chan,:));   %tenHZamppsd(chan) = sqrt(psdvec(6,1));   tenHZamppsd_bslflick(chan) = max(winmat_bslflick(chan,:))-min(winmat_bslflick(chan,:));   tenHZamppsd_letflick(chan) = max(winmat_letflick(chan,:))-min(winmat_letflick(chan,:));   end   %===========================================================% 5. bestimmung der mittleren Amplitude und Phase mit fft%===========================================================disp ('determining 10 Hz Phase per channel')clear chanfftMat_bslflick = fft (winmat_bslflick', 128);  % transpose: channels as columns (fft columnwise)PowerMat_bslflick = real(fftMat_bslflick.*conj(fftMat_bslflick)/128);AmpMat_bslflick = sqrt(PowerMat_bslflick);tenHZampfft_bslflick = AmpMat_bslflick(6,:);PhaseMat_bslflick = atan(real(fftMat_bslflick)./imag(fftMat_bslflick));Phasevec_bslflick = PhaseMat_bslflick(6,:);FourierCompVec_bslflick = fftMat_bslflick(6,:);fftMat_letflick = fft (winmat_letflick', 128);  % transpose: channels as columns (fft columnwise)PowerMat_letflick = real(fftMat_letflick.*conj(fftMat_letflick)/128);AmpMat_letflick = sqrt(PowerMat_letflick);tenHZampfft_letflick = AmpMat_letflick(6,:);PhaseMat_letflick = atan(real(fftMat_letflick)./imag(fftMat_letflick));Phasevec_letflick = PhaseMat_letflick(6,:);FourierCompVec_letflick = fftMat_letflick(6,:);%===========================================================% 6. bestimmung der mittleren Amplitude mit diffferenz(max-min)%===========================================================Difampvec_bslflick = max(winmat_bslflick')-min(winmat_bslflick');Difampvec_letflick = max(winmat_letflick')-min(winmat_letflick');