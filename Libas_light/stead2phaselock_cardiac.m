%==================================================================%%	stead2phaselock%% ermittelt fuer jede angegebene vp datenmatrix und% mittlere steady-state amplitude% sliding window procedure% ermittlung von amplitude in steady state daten	% matlab 4 erforderlich wegen yulewalk filterdesign%%Caution:psdvec = max-min - irrefuehrender Vektorname%!!!!!!!!!!! enter pairs as twocolumn-matrix%	%	Function definition function [phaselock_time, pairsynchmat] = stead2phaselock_cardiac(filemat, pairmat, plotflag);    if nargin < 2, plotflag = [], endexp = 'cardiac'ticfor fileindex = 1 : size(filemat,1);    	FilePath = deblank(filemat(fileindex,:) )	%===========================================================	% 1. lese daten einer vp und bedingung ein, falls nicht angegeben	%===========================================================		% if nargin<1;	% %rawmat = Readavgfile; % alles einschl baseline einlesen - atg junhoeferfile	% rawmat = read_avr_MEG(FilePath)	% else rawmat = Readavgfile(FilePath);	% end	% 	% 	[rawmat,File,Path,FilePath,NTrialAvgVec,StdChanTimeMat,...% 		SampRate,AvgRef,Version,MedMedRawVec,MedMedAvgVec,EegMegStatus,NChanExtra]= ReadAvgFile(FilePath);[rawmat,TSB,DI,SB,SC,NPoints,NChan,SampRate,TrigPoint,File,Path,FilePath, ...    SensorNames,SensorTypes]=ReadAsciiBesa(FilePath,'Avr',1);	%===========================================================	%filtern	%===========================================================	%disp('filtering data')		%filtmat=zeros(size(rawmat));		%M=[0 1 1 0 0];	%F=[0 0.004 0.2 0.2 1];		%[B, A] = YULEWALK(9,F,M);			%for nchan = 1 : 129;	%   Y = FILTFILT(B, A, rawmat(nchan,:));	%  filtmat(nchan,:) = Y;	%end		%%%%%% !!!!!!!	filtmat = rawmat;	    size (filtmat)		%============================================================	% 2. Baselinekorrektur	%===========================================================		disp ('subtracting baseline')		dimrawfile = size (rawmat);		datamat = zeros(size(rawmat));		if exp == 'cardiac', latms = 400; end		%latms = input('insert onset latency/baseline length (ms!!)    ');		latsp = latms/2;			bslvec = mean(filtmat(:,[latsp/2:latsp])');			for chan = 1 : size(datamat,1);				datamat(chan, :) = filtmat(chan,:) - bslvec(chan);		end				%===========================================================	% 3. moving window procedure mit jeweils 5 zyklen (=400ms/200sp),	% beginnend bei stimulusonset fuer alle kanaele. 	% shiften um 80ms (40sp) = 1 Zyklus	%===========================================================	disp('moving window procedure')        % downsample .....        datamat = datamat(:,1:2:size(datamat,2));            %===========================================================	% 3. moving window procedure mit jeweils 5 zyklen (=400ms/100sp),	% beginnend bei stimulusonset fuer alle kanaele. 	% shiften um 80ms (20sp) = 1 Zyklus	%===========================================================        latsp = 100		winmatsum = zeros(size(rawmat,1),100);	    fouriersum = zeros(1, size(rawmat,1));        interdiffsum = zeros(size(pairmat,1), 1);   	    if plotflag, h = figure, pause(1), end    	index = 1; 	for winshift = 0 : 20 : 1100 ; % shift nach baseline 101-1600        		winmatsum = (winmatsum + regressionMAT(datamat(:,[latsp+winshift:latsp+winshift+99])));                NFFT = 100; 	    NumUniquePts = ceil((NFFT+1)/2); 	    fftMat = fft(regressionMAT(datamat(:,[latsp+winshift:latsp+winshift+99]))', 100);  % transpose: channels as columns (fft columnwise)        tenHZampfft = abs(fftMat(6,:));        fouriercomp = fftMat(6,:);                 fouriersum = fouriersum + fouriercomp./tenHZampfft;                                            % inter site phase-locking                                for pairindex = 1:size(pairmat,1)                               interdiffsum(pairindex) = interdiffsum(pairindex) + (diff(fouriersum(pairmat(pairindex,:)))./abs(diff(fouriersum(pairmat(pairindex,:)))));              end               if plotflag           subplot(3,1,1), plot(1:4:100*4, regressionMAT(datamat(:,[latsp+winshift:latsp+winshift+99]))'), title(['sliding window starting at ' num2str((latsp+winshift)*4 -400)  ' ms ']), ylabel('microvolts')           subplot(3,1,2), plot(1:4:100*4, winmatsum'), title(['sum of sliding windows; number of shifts:' num2str(index) ]), xlabel('time in milliseconds')           subplot(3,1,3), hold on, circle([0,0],1,200,'-'); plot([0;(imag(fouriercomp(68)./tenHZampfft(68)))], [0;(real(fouriercomp(68)./tenHZampfft(68)))]);title('phase angle of window')            pause(0.1)          % movmat(index) = getframe(h)           pause(1)       else fprintf('.')       end                index = index+1; 	end	winmat = winmatsum./56;    phaselock_time_complex = fouriersum ./56;     phaselock_pairs_complex = interdiffsum ./(56);         phaselock_time = abs(phaselock_time_complex)';         phaselock_pairs = abs(phaselock_pairs_complex);     angle_pairs = angle(phaselock_pairs_complex);        pairsynchmat = [phaselock_pairs(1:size(pairmat,1)) angle_pairs(1:size(pairmat,1))]; 		% plot(winmat(73,:))	% title([FilePath])	% pause(5)		%===========================================================	% 3. detrending und demeaning der 5 verbleibenden zyklen:	% berechne least squares regression fuer jeden kanal	%===========================================================	%disp('demeaning of result')          	%	  for chan = 1:129;			  	%	      winmat(chan,:) = winmat(chan,:) 	%	  end	       	%===========================================================	% 5. determine amplitude and Phase using fft	%===========================================================	disp ('determining 10 Hz Phase per channel')		% for fft with amplitude scaling:		NFFT = 125; 	NumUniquePts = ceil((NFFT+1)/2); 	fftMat = fft (winmat', 100);  % transpose: channels as columns (fft columnwise)	Mag = abs(fftMat);                                                   % Amplitude berechnen	Mag = Mag*2;   		Mag(1) = Mag(1)/2;                                                    % DC trat aber nicht doppelt auf	if ~rem(NFFT,2),                                                    % Nyquist Frequenz (falls vorhanden) auch nicht doppelt        Mag(length(Mag))=Mag(length(Mag))/2;	end		Mag=Mag/NFFT;                                                         % FFT so skalieren, da? sie keine Funktion von NFFT ist		tenHZampfft = Mag(6,:);		PowerMat = real(fftMat.*conj(fftMat)/100);		%tenHZampfft = sqrt(PowerMat(6,:));		PhaseMat = atan(real(fftMat)./imag(fftMat));    	Phasevec = PhaseMat(6,:);	FourierCompVec = fftMat(6,:);	    real_part = real(FourierCompVec);     imag_part = imag(FourierCompVec); 		%===========================================================	% 6. bestimmung der mittleren Amplitude mit diffferenz(max-min)	%===========================================================		Phasevec = Phasevec';	tenHZampfft = tenHZampfft';		SaveAvgFile([FilePath '.amp' ],tenHZampfft,ones(129,1),[],SampRate)%             SaveAvgFile([FilePath '.win' ],winmat,ones(129,1),[],SampRate)%         % 	SaveAvgFile([FilePath '.pha' ],Phasevec,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus)%     %     SaveAvgFile([FilePath '.Tlock' ],phaselock_time,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus); %     %     SaveAvgFile([FilePath '.sync' ],pairsynchmat,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus);%     %     SaveAvgFile([FilePath '.real' ],real_part,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus);%     %     SaveAvgFile([FilePath '.imag' ],imag_part,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus);%     enda = toc; disp([num2str(a/60) ' minutes for this subject'])