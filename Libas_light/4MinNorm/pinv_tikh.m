% Computes pseudoinverse with Tikhonov-Phillips regulariztion for matrices whose% conditioning can be deduced from their dimensions, i.e. m<n => purely underdetermined% m>n => purely overdetermined,  m=n => nonsingular% Inversion is applied on Gram-matrices (numerically not optimal, but faster (?),% and especially if only few rows of the pseudoinverse are demanded memory saving% A: Matrix to be inverted (constraints see above)% lambda (optional): Tikhonov-Phillips regularization parameter (Gram(A)+lambda*I is inverted)% rows() (optional): Vector with rows of pseudoinverse G which shall be output% OH 29.10.97function  G = pinv_tikh(A, lambda, rows);[m n] = size(A)p = min(m,n)lambdazweitsum = lambda.*eye(p,p);size(zweitsum)erstsum = A*A';B = inv(A*A'+lambda*eye(p,p));INVtrans= size (B)if (m<n),			% Purely underdetermined problem	if (nargin==1) | (nargin==2)		% if no special rows selected		G = A'*inv(A*A'+lambda*eye(p,p));	else		C = inv(A*A'+lambda*eye(p,p));		% inverting Gram matrix		for i=1:length(rows)			G(i,:) = A(:,rows(i))'*C;		% Selecting rows for output		end;	end;end;if (m>n),			% Purely overdetermined problem	if (nargin==1) | (nargin==2)		G = inv(A'*A+lambda*eye(p,p))*A';		else		C = inv(A'*A+lambda*eye(p,p));		for i=1:length(rows)			G(i,:) = C(rows(i),:)*A';		end;	end;	end;if (m==n)			% Well-determined problem	if (nargin==1) | (nargin==2)		G = inv(A+lambda*eye(p,p));		else		C = inv(A+lambda*eye(p,p));		for i=1:length(rows)			G(i,:) = C(rows(i),:);		end;	end;end;clear C;