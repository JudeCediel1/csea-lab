function [diploc, lfdmat, data, n, G, invsol] = invmapmn(lfdmat, regpar, pathname, namelist, pathout, elplist, from, to);if nargin==0,   disp(' [diploc, lfdmat, data, G, invsol] = invmapmn(lfdmat, regpar, pathname, namelist, pathout, elplist, from, to); ');   return;end;isfrom = 1;if isempty(from),   isfrom=0;end;nr_names = length(namelist(:,1)); disp('Reading in data, average referencing');name = sprintf('%s\\%s', pathname, namelist(1,:));disp(name);[matrix, latencies] = read_avr(name);TSB(1) = latencies(1);if length(latencies)>1, DI(1)=latencies(2)-latencies(1); else DI(1)=1; end;[m(1) n(1)] = size(matrix);disp(' Determine valid electrodes to be included in the following procedure');nr_electrodes = 0;for i=1:m(1),	pruef = 0;	for j=1:length(elplist),		if elplist(j)==i,			pruef = 1;			break;		end;	end;	if pruef==0,		nr_electrodes = nr_electrodes + 1;		arg(nr_electrodes) = i;	end;end;nr_electrodesif isfrom==0, from=1; to=n(1); end;n(1) = to-from+1;data(:,1:n(1), 1) =  matrix(arg,from:to);data(:,1:n(1), 1) = avg_ref(data(:,1:n(1), 1));m(1)for i=2:nr_names,				% Reading in additional files	name = sprintf('%s\\%s', pathname, namelist(i,:));	disp(name);   [matrix, latencies] = read_avr(name);   TSB(i) = latencies(1);   if length(latencies)>1, DI(i)=latencies(2)-latencies(1); else DI(i)=1; end;   [m(i) n(i)] = size(matrix);    if isfrom==0, from=1; to=n(i); end;   n(i) = to-from+1;   data(:,1:n(i), i) =  matrix(arg,from:to);	data(:,1:n(i), i) = avg_ref(data(:,1:n(i), i));	m(i)end;disp('Reading dipole locations (diploc)');diploc = read_matrix(1384, 3, 'c:\Matlab\analysis\elp\diploc_sph_08_02_01_-06.dat');diploc = diploc';if isempty(lfdmat),	disp('Reading leadfield matrix (lfdmat)');	lfdmat = read_matrix(4152, 21, 'c:\Matlab\analysis\elp\lead21_sph_08_02_01_-06.dat');	lfdmat = lfdmat';	size(lfdmat)end; if length(regpar)==1,			% One regularization parameter for all data	disp('Computing pseudoinverse (G)');	G = pinv_tikh(lfdmat, regpar);   size(G)	q = when_changes_radius(diploc, 0.001);	disp('Computing and writing  inverse solutions (invsol)');	dim = 3;	for i=1:nr_names,		inv =  inv_recon(G(1:(dim*q(1)),:), data(1:nr_electrodes,1:n(i),i), dim);		invsol(:,1:n(i),i) =inv;		filename = sprintf('%s\\%s_mnmap.avr', pathout, namelist(i,1:3));		disp(filename);		fid = fopen(filename, 'w');		fprintf(fid, 'Npts= %d  TSB= %f  DI= %f  SB= 1.000  SC= 1.0\n', n(i), TSB(i), DI(i));		[z s] = size(inv);		for k=1:z,			for j=1:s,				fprintf(fid, '%f ', inv(k,j));			end;			fprintf(fid, '\n');		end;		fclose(fid);	end;end;if length(regpar)>1,			% Separate regularization parameters for each data point   q = when_changes_radius(diploc, 0.001);   dim = 3;	disp('Computing and writing  inverse solutions (invsol)');	dim = 3;   for i=1:nr_names,      for j=1:n(i),         disp('Computing pseudoinverse (G)');			G = pinv_tikh(lfdmat, regpar(j,i));			inv =  inv_recon(G(1:(dim*q(1)),:), data(1:nr_electrodes,j,i), dim);			invsol(:,j,i) =inv;			      end;      filename = sprintf('%s\\%s_mnmap.avr', pathout, namelist(i,1:3));		disp(filename);		fid = fopen(filename, 'w');		fprintf(fid, 'Npts= %d  TSB= %f  DI= %f  SB= 1.000  SC= 1.0\n', n(i), TSB(i), DI(i));		[z s] = size(invsol(:,:,i));		for k=1:z,			for j=1:s,				fprintf(fid, '%f ', invsol(k,j,i));			end;			fprintf(fid, '\n');		end;		fclose(fid);   end;end;