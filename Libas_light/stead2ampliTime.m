%==================================================================%%	stead2amplitude%% ermittelt fuer jede angegebene vp datenmatrix und% mittlere steady-state amplitude% sliding window procedure% ermittlung von amplitude in steady state daten	% matlab 4 erforderlich wegen yulewalk filterdesign%% Andreas 13.11.1998%%	%	Function definition%================================================================== function [tenHZampfft, Phasevec, Difampvec, TFourierCompVec] = stead2ampliTime(FilePath);exp = 'emosteady'%===========================================================% 1. lese daten einer vp und bedingung ein, falls nicht angegeben%===========================================================if nargin<1;rawmat = Readavgfile; 				% alles einschl baseline einlesenelse rawmat = Readavgfile(FilePath);end%===========================================================%filtern%===========================================================%disp('filtering data')%filtmat=zeros(size(rawmat));%M=[0 1 1 0 0];%F=[0 0.004 0.2 0.2 1];%[B, A] = YULEWALK(9,F,M);%for nchan = 1 : 129;%   Y = FILTFILT(B, A, rawmat(nchan,:));%  filtmat(nchan,:) = Y;%end%%%%%% !!!!!!!filtmat = rawmat;tenHZampfft = []Phasevec = []Difampvec = []%============================================================% 2. Baselinekorrektur%===========================================================disp ('subtracting baseline')dimrawfile = size (rawmat);datamat = zeros(size(rawmat));if exp == 'emosteady', latms = 800; end%latms = input('insert onset latency/baseline length (ms!!)    ');latsp = latms/4;bslvec = mean(filtmat(:,[latsp/2:latsp])');   for chan = 1 : 129;		datamat(chan, :) = filtmat(chan,:) - bslvec(chan);   end	for startsp = 0:250:1000%===========================================================% 3. moving window procedure mit jeweils 5 zyklen (=500ms/125sp),% beginnend bei stimulusonset fuer alle kanaele. % shiften um 100ms (25sp) = >1 Zyklus ueber jeweils eine sekunde%===========================================================disp('moving window procedure for several time ranges')winmatsum = zeros(129,125);for winshift = startsp : 25 : startsp+225 ;              % shift nach baseline 101-1600	winmatsum = (winmatsum + datamat(:,[latsp+winshift:latsp+winshift+124]));	winmat = winmatsum./10;end%===========================================================% 3. detrending und demeaning der 5 verbleibenden zyklen:% berechne least squares regression fuer jeden kanal%===========================================================%disp('demeaning of result')      %	  for chan = 1:129;		  %	      winmat(chan,:) = winmat(chan,:) - winmat(chan,1);	  %	  end% save ubies:transport:winmatvor winmat -ascii%===========================================================% 4. bestimmung der mittleren Amplitude fuer jeden Kanal mit psd%===========================================================disp ('determining mean 10 Hz amplitude per channel')clear chan%for chan = 1 : 129;      %psdvec = psd(winmat(chan,:));   %tenHZamppsd(chan) = sqrt(psdvec(6,1));   %tenHZamppsd(chan) = max(winmat(chan,:))-min(winmat(chan,:));%end   %===========================================================% 5. bestimmung der mittleren Amplitude und Phase mit fft%===========================================================disp ('determining 10 Hz Phase per channel')clear chanfftMat = fft(winmat', 128);     	  % transpose: channels as columns (fft columnwise)PowerMat = real(fftMat.*conj(fftMat)/128);AmpMat = sqrt(PowerMat);tenHZampfft = [tenHZampfft AmpMat(6,:)];PhaseMat = atan(real(fftMat)./imag(fftMat));Phasevec = [Phasevec PhaseMat(6,:)];TFourierCompVec= [TFourierCompVec fftMat(6,:)];%===========================================================% 6. bestimmung der mittleren Amplitude mit diffferenz(max-min)%===========================================================Difampvec = [Difampvec max(winmat')-min(winmat')];end