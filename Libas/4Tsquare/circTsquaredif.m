% circTsquaredif% computes circular T^2 statistic for Fourier components (at a given frequency, here 10 Hz, from% FFT on steady-state data. Inputfile: Mat-format (complex) 129 X nr_independent estimates% => test for significant differences M = number of estimates must be equal across conditions for the algorithm below%note : circTsquare is not yet F distributed, but (m^2/(M+M)) * circTsquare is distributed according to F(2, M + M - 4)%%%			Andreas am 10.03.1999%%function[Tsquarevecdiff] = circTsquaredif(Fouriercompmat1, Fouriercompmat2);albedmat1 = Fouriercompmat1';albedmat2 = Fouriercompmat2';	% two estimates for the population variance are computed for each electrode% 1.) V_indiv% 2.) V_group% dazu noetig:  M; mean Z = Zest = xest + i YestM = length(albedmat1(1,:))%1 complex mean for each electrode: Z_est = xest + i YestmeanZvec1 = mean(albedmat1');meanZvec2 = mean(albedmat2');%2 V_indiv for each electrode: Variance with 1/2(M-1)% dazu : erzeuge complexen vector mit summe der(residuen v. Stichprobenmittelwert)for elc = 1 : 129;	for estim = 1 : M	squareVec1(estim)= (real(albedmat1(elc,estim)-meanZvec1(elc))).^2 + (imag(albedmat1(elc,estim)-meanZvec1(elc))).^2; 	% Residuen 	squareVec2(estim)= (real(albedmat2(elc,estim)-meanZvec2(elc))).^2 + (imag(albedmat2(elc,estim)-meanZvec2(elc))).^2;	end	V_indiVec(elc) = (sum(squareVec1) + sum(squareVec2)) ./ (2*(2*M-2)) ;      % V_indiv fuer jede Elektrodeend% 3 V_group for each electrode: depends on population mean disp(' ')for elc = 1 : 129;	squarepop(elc) = (real(meanZvec1(elc)) - real(meanZvec2(elc))).^2 + (imag(meanZvec1(elc)) - imag(meanZvec2(elc))).^2;	V_groupVec(elc) = squarepop(elc) .* (M * M)/(2*(M + M));           % V_group fuer jede ElektrodeendTsquarevecdiff = (V_groupVec ./ V_indiVec) .* ((M+M)/M*M);DFnenner =  2*(M + M -2);fprintf('DF for circTsquare final F value [(m^2/(M+M)) * circTsquare] : 2 df numerator, %g df denominator', DFnenner)