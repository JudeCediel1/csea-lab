static char mc_version[] = "MATLAB Compiler 1.2 Jan  7 1998 infun";/* *  MATLAB Compiler: 1.2 *  Date: Jan  7 1998 *  Arguments: circTsquare  */#ifndef ARRAY_ACCESS_INLINING#error You must use the -inline option when compiling MATLAB compiler generated code with MEX or MBUILD#endif#ifndef MATLAB_COMPILER_GENERATED_CODE#define MATLAB_COMPILER_GENERATED_CODE#endif#include <math.h>#include "mex.h"#include "mcc.h"/* static array S0_ (1 x 8) text, line 25: 'albedmat' */static unsigned short S0__r_[] ={         97,  108,   98,  101,  100,  109,   97,  116,};static mxArray S0_ = mccCINIT( mccTEXT,  1, 8, S0__r_, 0);/* static array S1_ (1 x 34) text, line 42: 'hypothesized population m...' */static unsigned short S1__r_[] ={        104,  121,  112,  111,  116,  104,  101,  115,        105,  122,  101,  100,   32,  112,  111,  112,        117,  108,   97,  116,  105,  111,  110,   32,        109,  101,   97,  110,   58,   32,  122,  101,        114,  111,};static mxArray S1_ = mccCINIT( mccTEXT,  1, 34, S1__r_, 0);/* static array S2_ (1 x 1) text, line 43: ' ' */static unsigned short S2__r_[] ={         32,};static mxArray S2_ = mccCINIT( mccTEXT,  1, 1, S2__r_, 0);/* static array S3_ (1 x 8) text, line 25: 'albedmat' */static unsigned short S3__r_[] ={         97,  108,   98,  101,  100,  109,   97,  116,};static mxArray S3_ = mccCINIT( mccTEXT,  1, 8, S3__r_, 0);/* static array S4_ (1 x 34) text, line 42: 'hypothesized population m...' */static unsigned short S4__r_[] ={        104,  121,  112,  111,  116,  104,  101,  115,        105,  122,  101,  100,   32,  112,  111,  112,        117,  108,   97,  116,  105,  111,  110,   32,        109,  101,   97,  110,   58,   32,  122,  101,        114,  111,};static mxArray S4_ = mccCINIT( mccTEXT,  1, 34, S4__r_, 0);/* static array S5_ (1 x 1) text, line 43: ' ' */static unsigned short S5__r_[] ={         32,};static mxArray S5_ = mccCINIT( mccTEXT,  1, 1, S5__r_, 0);/***************** Compiler Assumptions **************** * *       B0_         	boolean scalar temporary *       C0_         	complex scalar temporary *       C1_         	complex scalar temporary *       CM0_        	complex vector/matrix temporary *       Fouriercompfilepath	complex vector/matrix *       I0_         	integer scalar temporary *       I1_         	integer scalar temporary *       M           	integer scalar *       MatName     	complex vector/matrix *       MatName     	string vector/matrix  => MatName_1 *       R0_         	real scalar temporary *       R1_         	real scalar temporary *       RM0_        	real vector/matrix temporary *       Tsquarevec  	real vector/matrix *       V_groupVec  	real vector/matrix *       V_indiVec   	real vector/matrix *       albedmat    	complex vector/matrix *       circTsquare 	<function being defined> *       disp        	<function> *       elc         	integer scalar *       estim       	integer scalar *       imag        	<function> *       length      	<function> *       mean        	<function> *       meanZvec    	complex vector/matrix *       nargin      	<function> *       real        	<function> *       squareVec   	real vector/matrix *       squarepop   	real scalar *       sum         	<function> *******************************************************/voidmexFunction(    int nlhs_,    mxArray *plhs_[],    int nrhs_,    const mxArray *prhs_[]){   int ci_;   int i_;   mxArray *Mplhs_[1];   mxArray *Mprhs_[1];      if (nrhs_ > 2 )   {      mexErrMsgTxt( "Too many input arguments." );   }   if (nlhs_ > 1 )   {      mexErrMsgTxt( "Too many output arguments." );   }   for (ci_=i_=0; i_<nrhs_; ++i_)   {      if ( mccPI(prhs_[i_]) )      {         ci_ = 1;         break;      }   }   if (ci_)   {      mxArray Tsquarevec;      mxArray Fouriercompfilepath;      mxArray MatName;      mxArray MatName_1;      mxArray albedmat;      int M = 0;      mxArray meanZvec;      int elc = 0;      int estim = 0;      mxArray squareVec;      mxArray V_indiVec;      double squarepop = 0.0;      mxArray V_groupVec;      int I0_ = 0;      unsigned short B0_ = 0;      mxArray CM0_;      int I1_ = 0;      double C0__r=0.0, C0__i=0.0;      double R0_ = 0.0;      double C1__r=0.0, C1__i=0.0;      double R1_ = 0.0;      mxArray RM0_;            mccComplexInit(Fouriercompfilepath);      mccImport(&Fouriercompfilepath, ((nrhs_>0) ? prhs_[0] : 0), 0, 0);      mccComplexInit(MatName);      mccImport(&MatName, ((nrhs_>1) ? prhs_[1] : 0), 0, 0);      mccRealInit(Tsquarevec);      mccTextInit(MatName_1);      mccComplexInit(albedmat);      mccComplexInit(meanZvec);      mccRealInit(squareVec);      mccRealInit(V_indiVec);      mccRealInit(V_groupVec);      mccComplexInit(CM0_);      mccRealInit(RM0_);                  /* if nargin <2; */      I0_ = mccNargin();      B0_ = (I0_ < 2);      if ((double)B0_)      {         /* MatName = 'albedmat' */         mccCreateString(&MatName_1, "albedmat");         mccPrint (&MatName_1, "MatName_1");         /* end */      }            /* % if nargin<1; */      /* % load_it */      /* % else eval(['load ' Fouriercompfilepath]) */      /* % end */            /* % two estimates for the population variance are computed for eacvh electrode */      /* % 1.) V_indiv */      /* % 2.) V_group */      /* % dazu noetig:  M; mean Z = Zest = xest + i Yest */            /* M = length(albedmat(1,:)) */      mccUndefVariable(&albedmat, &S0_);      {         int i_, j_;         int m_=1, n_=1, cx_ = 0;         double *p_CM0_;         int I_CM0_=1;         double *q_CM0_;         double *p_albedmat;         int I_albedmat=1, J_albedmat;         double *q_albedmat;         m_ = mcmCalcResultSize(m_, &n_, 1, mccN(&albedmat));         mccAllocateMatrix(&CM0_, m_, n_);         mccCheckMatrixSize(&albedmat, 1, mccN(&albedmat));         I_CM0_ = (mccM(&CM0_) != 1 || mccN(&CM0_) != 1);         p_CM0_ = mccPR(&CM0_);         q_CM0_ = mccPI(&CM0_);         if (mccN(&albedmat) == 1) { I_albedmat = J_albedmat = 0;}         else { I_albedmat = 1; J_albedmat=mccM(&albedmat)-m_; }         p_albedmat = mccPR(&albedmat) + (1-1) + mccM(&albedmat) * 0;         q_albedmat = mccPI(&albedmat) + (1-1) + mccM(&albedmat) * 0;         if (m_ != 0)         {            for (j_=0; j_<n_; ++j_, p_albedmat += J_albedmat, q_albedmat += J_albedmat)            {               for (i_=0; i_<m_; ++i_, p_CM0_+=I_CM0_, q_CM0_+=I_CM0_, p_albedmat+=I_albedmat, q_albedmat+=I_albedmat)               {                  *p_CM0_ = *p_albedmat;                  *q_CM0_ = 0.;               }            }         }      }      M = mccGetLength(&CM0_);      mccPrint (mccTempMatrix(M, 0., mccINT, 0 ), "M");            /* % 1 complex mean for each electrode: Z_est = xest + i Yest */      /* meanZvec = mean(albedmat'); */      mccConjTrans(&CM0_, &albedmat);      Mprhs_[0] = &CM0_;      Mplhs_[0] = &meanZvec;      mccCallMATLAB(1, Mplhs_, 1, Mprhs_, "mean", 28);            /* % 2 V_indiv for each electrode: Variance with 1/2(M-1) */      /* % dazu : erzeuge complexen vector mit summe der(residuen v. Stichprobenmittelwert) */      /* for elc = 1 : 129; */      for (I0_ = 1; I0_ <= 129; I0_ = I0_ + 1)      {         elc = I0_;         /* for estim = 1 : M */         for (I1_ = 1; I1_ <= M; I1_ = I1_ + 1)         {            estim = I1_;            /* squareVec(estim)= (real(albedmat(elc,estim)-meanZvec(elc))).^2 + (imag(albedmat(elc,estim)-meanZvec(elc))).^2;  	% Residuen  */            C0__r = ((mccGetRealMatrixElement(&albedmat, mccRint(elc), mccRint(estim))) - (mccGetRealVectorElement(&meanZvec, mccRint(elc))));            C0__i = (mccGetImagMatrixElement(&albedmat, mccRint(elc), mccRint(estim)) - mccGetImagVectorElement(&meanZvec, mccRint(elc)));            R0_ = mcmReal(C0__r, C0__i);            C1__r = ((mccGetRealMatrixElement(&albedmat, mccRint(elc), mccRint(estim))) - (mccGetRealVectorElement(&meanZvec, mccRint(elc))));            C1__i = (mccGetImagMatrixElement(&albedmat, mccRint(elc), mccRint(estim)) - mccGetImagVectorElement(&meanZvec, mccRint(elc)));            R1_ = mcmImag(C1__r, C1__i);            mccSetRealVectorElement(&squareVec, mccRint(estim), (mcmRealPowerInt(R0_, 2) + mcmRealPowerInt(R1_, 2)));            /* end */         }         /* V_indiVec(elc) = sum(squareVec) / (2*(M-1));           % V_indiv fuer jede Elektrode */         mccSum(&RM0_, &squareVec);         R1_ = (mccGetRealVectorElement(&RM0_, mccRint(1)));         mccSetRealVectorElement(&V_indiVec, mccRint(elc), (R1_ / (double) (2 * (double) (M - 1))));         /* end */      }            /* % 3 V_group for each electrode: depends on population mean  */      /* % is signal present - i.e. is population mean = 0 i0 ? */            /* disp('hypothesized population mean: zero') */      Mprhs_[0] = &S1_;      Mplhs_[0] = 0;      mccCallMATLAB(0, Mplhs_, 1, Mprhs_, "disp", 42);      /* disp(' ') */      Mprhs_[0] = &S2_;      Mplhs_[0] = 0;      mccCallMATLAB(0, Mplhs_, 1, Mprhs_, "disp", 43);      /* for elc = 1 : 129; */      for (I0_ = 1; I0_ <= 129; I0_ = I0_ + 1)      {         elc = I0_;         /* squarepop = real(meanZvec(elc)).^2 + imag(meanZvec(elc)).^2; */         R1_ = mcmReal((mccGetRealVectorElement(&meanZvec, mccRint(elc))), mccGetImagVectorElement(&meanZvec, mccRint(elc)));         R0_ = mcmImag((mccGetRealVectorElement(&meanZvec, mccRint(elc))), mccGetImagVectorElement(&meanZvec, mccRint(elc)));         squarepop = (mcmRealPowerInt(R1_, 2) + mcmRealPowerInt(R0_, 2));         /* V_groupVec(elc) = (squarepop .* (M/2));           % V_indiv fuer jede Elektrode */         mccSetRealVectorElement(&V_groupVec, mccRint(elc), (squarepop * (double) (M / (double) 2)));         /* end */      }                        /* Tsquarevec = (V_groupVec ./ V_indiVec) / M; */      {         int i_, j_;         int m_=1, n_=1, cx_ = 0;         double *p_Tsquarevec;         int I_Tsquarevec=1;         double *p_V_groupVec;         int I_V_groupVec=1;         double *p_V_indiVec;         int I_V_indiVec=1;         m_ = mcmCalcResultSize(m_, &n_, mccM(&V_groupVec), mccN(&V_groupVec));         m_ = mcmCalcResultSize(m_, &n_, mccM(&V_indiVec), mccN(&V_indiVec));         mccAllocateMatrix(&Tsquarevec, m_, n_);         I_Tsquarevec = (mccM(&Tsquarevec) != 1 || mccN(&Tsquarevec) != 1);         p_Tsquarevec = mccPR(&Tsquarevec);         I_V_groupVec = (mccM(&V_groupVec) != 1 || mccN(&V_groupVec) != 1);         p_V_groupVec = mccPR(&V_groupVec);         I_V_indiVec = (mccM(&V_indiVec) != 1 || mccN(&V_indiVec) != 1);         p_V_indiVec = mccPR(&V_indiVec);         if (m_ != 0)         {            for (j_=0; j_<n_; ++j_)            {               for (i_=0; i_<m_; ++i_, p_Tsquarevec+=I_Tsquarevec, p_V_groupVec+=I_V_groupVec, p_V_indiVec+=I_V_indiVec)               {                  *p_Tsquarevec = ((*p_V_groupVec / (double) *p_V_indiVec) / (double) M);               }            }         }      }                                          mccReturnFirstValue(&plhs_[0], &Tsquarevec);   }   else   {/***************** Compiler Assumptions **************** * *       B0_         	boolean scalar temporary *       C0_         	complex scalar temporary *       C1_         	complex scalar temporary *       CM0_        	complex vector/matrix temporary *       Fouriercompfilepath	real vector/matrix *       I0_         	integer scalar temporary *       I1_         	integer scalar temporary *       M           	integer scalar *       MatName     	real vector/matrix *       MatName     	string vector/matrix  => MatName_1 *       R0_         	real scalar temporary *       R1_         	real scalar temporary *       RM0_        	real vector/matrix temporary *       Tsquarevec  	real vector/matrix *       V_groupVec  	real vector/matrix *       V_indiVec   	real vector/matrix *       albedmat    	complex vector/matrix *       circTsquare 	<function being defined> *       disp        	<function> *       elc         	integer scalar *       estim       	integer scalar *       imag        	<function> *       length      	<function> *       mean        	<function> *       meanZvec    	complex vector/matrix *       nargin      	<function> *       real        	<function> *       squareVec   	real vector/matrix *       squarepop   	real scalar *       sum         	<function> *******************************************************/      mxArray Tsquarevec;      mxArray Fouriercompfilepath;      mxArray MatName;      mxArray MatName_1;      mxArray albedmat;      int M = 0;      mxArray meanZvec;      int elc = 0;      int estim = 0;      mxArray squareVec;      mxArray V_indiVec;      double squarepop = 0.0;      mxArray V_groupVec;      int I0_ = 0;      unsigned short B0_ = 0;      mxArray CM0_;      int I1_ = 0;      double C0__r=0.0, C0__i=0.0;      double R0_ = 0.0;      double C1__r=0.0, C1__i=0.0;      double R1_ = 0.0;      mxArray RM0_;            mccRealInit(Fouriercompfilepath);      mccImport(&Fouriercompfilepath, ((nrhs_>0) ? prhs_[0] : 0), 0, 0);      mccRealInit(MatName);      mccImport(&MatName, ((nrhs_>1) ? prhs_[1] : 0), 0, 0);      mccRealInit(Tsquarevec);      mccTextInit(MatName_1);      mccComplexInit(albedmat);      mccComplexInit(meanZvec);      mccRealInit(squareVec);      mccRealInit(V_indiVec);      mccRealInit(V_groupVec);      mccComplexInit(CM0_);      mccRealInit(RM0_);                  /* if nargin <2; */      I0_ = mccNargin();      B0_ = (I0_ < 2);      if ((double)B0_)      {         /* MatName = 'albedmat' */         mccCreateString(&MatName_1, "albedmat");         mccPrint (&MatName_1, "MatName_1");         /* end */      }            /* % if nargin<1; */      /* % load_it */      /* % else eval(['load ' Fouriercompfilepath]) */      /* % end */            /* % two estimates for the population variance are computed for eacvh electrode */      /* % 1.) V_indiv */      /* % 2.) V_group */      /* % dazu noetig:  M; mean Z = Zest = xest + i Yest */            /* M = length(albedmat(1,:)) */      mccUndefVariable(&albedmat, &S3_);      {         int i_, j_;         int m_=1, n_=1, cx_ = 0;         double *p_CM0_;         int I_CM0_=1;         double *q_CM0_;         double *p_albedmat;         int I_albedmat=1, J_albedmat;         double *q_albedmat;         m_ = mcmCalcResultSize(m_, &n_, 1, mccN(&albedmat));         mccAllocateMatrix(&CM0_, m_, n_);         mccCheckMatrixSize(&albedmat, 1, mccN(&albedmat));         I_CM0_ = (mccM(&CM0_) != 1 || mccN(&CM0_) != 1);         p_CM0_ = mccPR(&CM0_);         q_CM0_ = mccPI(&CM0_);         if (mccN(&albedmat) == 1) { I_albedmat = J_albedmat = 0;}         else { I_albedmat = 1; J_albedmat=mccM(&albedmat)-m_; }         p_albedmat = mccPR(&albedmat) + (1-1) + mccM(&albedmat) * 0;         q_albedmat = mccPI(&albedmat) + (1-1) + mccM(&albedmat) * 0;         if (m_ != 0)         {            for (j_=0; j_<n_; ++j_, p_albedmat += J_albedmat, q_albedmat += J_albedmat)            {               for (i_=0; i_<m_; ++i_, p_CM0_+=I_CM0_, q_CM0_+=I_CM0_, p_albedmat+=I_albedmat, q_albedmat+=I_albedmat)               {                  *p_CM0_ = *p_albedmat;                  *q_CM0_ = 0.;               }            }         }      }      M = mccGetLength(&CM0_);      mccPrint (mccTempMatrix(M, 0., mccINT, 0 ), "M");            /* % 1 complex mean for each electrode: Z_est = xest + i Yest */      /* meanZvec = mean(albedmat'); */      mccConjTrans(&CM0_, &albedmat);      Mprhs_[0] = &CM0_;      Mplhs_[0] = &meanZvec;      mccCallMATLAB(1, Mplhs_, 1, Mprhs_, "mean", 28);            /* % 2 V_indiv for each electrode: Variance with 1/2(M-1) */      /* % dazu : erzeuge complexen vector mit summe der(residuen v. Stichprobenmittelwert) */      /* for elc = 1 : 129; */      for (I0_ = 1; I0_ <= 129; I0_ = I0_ + 1)      {         elc = I0_;         /* for estim = 1 : M */         for (I1_ = 1; I1_ <= M; I1_ = I1_ + 1)         {            estim = I1_;            /* squareVec(estim)= (real(albedmat(elc,estim)-meanZvec(elc))).^2 + (imag(albedmat(elc,estim)-meanZvec(elc))).^2;  	% Residuen  */            C0__r = ((mccGetRealMatrixElement(&albedmat, mccRint(elc), mccRint(estim))) - (mccGetRealVectorElement(&meanZvec, mccRint(elc))));            C0__i = (mccGetImagMatrixElement(&albedmat, mccRint(elc), mccRint(estim)) - mccGetImagVectorElement(&meanZvec, mccRint(elc)));            R0_ = mcmReal(C0__r, C0__i);            C1__r = ((mccGetRealMatrixElement(&albedmat, mccRint(elc), mccRint(estim))) - (mccGetRealVectorElement(&meanZvec, mccRint(elc))));            C1__i = (mccGetImagMatrixElement(&albedmat, mccRint(elc), mccRint(estim)) - mccGetImagVectorElement(&meanZvec, mccRint(elc)));            R1_ = mcmImag(C1__r, C1__i);            mccSetRealVectorElement(&squareVec, mccRint(estim), (mcmRealPowerInt(R0_, 2) + mcmRealPowerInt(R1_, 2)));            /* end */         }         /* V_indiVec(elc) = sum(squareVec) / (2*(M-1));           % V_indiv fuer jede Elektrode */         mccSum(&RM0_, &squareVec);         R1_ = (mccGetRealVectorElement(&RM0_, mccRint(1)));         mccSetRealVectorElement(&V_indiVec, mccRint(elc), (R1_ / (double) (2 * (double) (M - 1))));         /* end */      }            /* % 3 V_group for each electrode: depends on population mean  */      /* % is signal present - i.e. is population mean = 0 i0 ? */            /* disp('hypothesized population mean: zero') */      Mprhs_[0] = &S4_;      Mplhs_[0] = 0;      mccCallMATLAB(0, Mplhs_, 1, Mprhs_, "disp", 42);      /* disp(' ') */      Mprhs_[0] = &S5_;      Mplhs_[0] = 0;      mccCallMATLAB(0, Mplhs_, 1, Mprhs_, "disp", 43);      /* for elc = 1 : 129; */      for (I0_ = 1; I0_ <= 129; I0_ = I0_ + 1)      {         elc = I0_;         /* squarepop = real(meanZvec(elc)).^2 + imag(meanZvec(elc)).^2; */         R1_ = mcmReal((mccGetRealVectorElement(&meanZvec, mccRint(elc))), mccGetImagVectorElement(&meanZvec, mccRint(elc)));         R0_ = mcmImag((mccGetRealVectorElement(&meanZvec, mccRint(elc))), mccGetImagVectorElement(&meanZvec, mccRint(elc)));         squarepop = (mcmRealPowerInt(R1_, 2) + mcmRealPowerInt(R0_, 2));         /* V_groupVec(elc) = (squarepop .* (M/2));           % V_indiv fuer jede Elektrode */         mccSetRealVectorElement(&V_groupVec, mccRint(elc), (squarepop * (double) (M / (double) 2)));         /* end */      }                        /* Tsquarevec = (V_groupVec ./ V_indiVec) / M; */      {         int i_, j_;         int m_=1, n_=1, cx_ = 0;         double *p_Tsquarevec;         int I_Tsquarevec=1;         double *p_V_groupVec;         int I_V_groupVec=1;         double *p_V_indiVec;         int I_V_indiVec=1;         m_ = mcmCalcResultSize(m_, &n_, mccM(&V_groupVec), mccN(&V_groupVec));         m_ = mcmCalcResultSize(m_, &n_, mccM(&V_indiVec), mccN(&V_indiVec));         mccAllocateMatrix(&Tsquarevec, m_, n_);         I_Tsquarevec = (mccM(&Tsquarevec) != 1 || mccN(&Tsquarevec) != 1);         p_Tsquarevec = mccPR(&Tsquarevec);         I_V_groupVec = (mccM(&V_groupVec) != 1 || mccN(&V_groupVec) != 1);         p_V_groupVec = mccPR(&V_groupVec);         I_V_indiVec = (mccM(&V_indiVec) != 1 || mccN(&V_indiVec) != 1);         p_V_indiVec = mccPR(&V_indiVec);         if (m_ != 0)         {            for (j_=0; j_<n_; ++j_)            {               for (i_=0; i_<m_; ++i_, p_Tsquarevec+=I_Tsquarevec, p_V_groupVec+=I_V_groupVec, p_V_indiVec+=I_V_indiVec)               {                  *p_Tsquarevec = ((*p_V_groupVec / (double) *p_V_indiVec) / (double) M);               }            }         }      }                                          mccReturnFirstValue(&plhs_[0], &Tsquarevec);   }   return;}