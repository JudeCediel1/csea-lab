% D_stat_topos, according to Galan et al., 1997% computes D-statistic for comparison of two topographies (matrices% with [elec X time points]) % also computes permutation distribution for signif. test% Nsens4D = number of sensors four D statisticfunction 	[D, Dperm] = D_stat_topos(topo1, topo2, Nsens4D)						[topo1_sorted_ascend, Index_1] = sort(topo1);			[topo2_sorted_ascend, Index_2] = sort(topo2);						% vectors: elecs sorted in descending order (max two min)				elec_sorted_1 = flipud(Index_1);			elec_sorted_2 = flipud(Index_2);						elec_sorted_1 = elec_sorted_1(1:Nsens4D);			elec_sorted_2 = elec_sorted_2(1:Nsens4D);						% compute distances					   load ('elek129HCLnorm_forMNE.dat')						elek = (elek129HCLnorm_forMNE * 10); % put on a unit sphere							diffvecX = elek(elec_sorted_1,1) - elek(elec_sorted_2,1);			diffvecY = elek(elec_sorted_1,2) - elek(elec_sorted_2,2);			diffvecZ = elek(elec_sorted_1,3) - elek(elec_sorted_2,3);				% euclidean distances			diffvecabs = sqrt(diffvecX.^2 + diffvecY.^2 + diffvecZ.^2);			D = (sum(diffvecabs))./Nsens4D;                         % now do the permutation stats for that comparison            % disp(start permutation ...')                         for draw = 1:5000                                                  topo1_perm = (topo1(randperm(length(topo1))));                          topo2_perm = (topo2(randperm(length(topo2))));                                                    [topo1_sorted_ascend, Index_1] = sort(topo1_perm);                         [topo2_sorted_ascend, Index_2] = sort(topo2_perm);			                        % vectors: elecs sorted in descending order (max two min)	                        elec_sorted_1 = flipud(Index_1);                        elec_sorted_2 = flipud(Index_2);			                        elec_sorted_1 = elec_sorted_1(1:Nsens4D);                        elec_sorted_2 = elec_sorted_2(1:Nsens4D);			                        diffvecX = elek(elec_sorted_1,1) - elek(elec_sorted_2,1);                        diffvecY = elek(elec_sorted_1,2) - elek(elec_sorted_2,2);                        diffvecZ = elek(elec_sorted_1,3) - elek(elec_sorted_2,3);				% euclidean distances			diffvecabs = sqrt(diffvecX.^2 + diffvecY.^2 + diffvecZ.^2);			Dperm(draw) = (sum(diffvecabs))./Nsens4D;                         if draw./500 == round(draw./500), fprintf('.'), end                                               end																											