%==================================================================%%	stead2phaselock%% sliding window procedure%%!!!!!!!!!!! enter pairs as twocolumn-matrix%	%	Function definition function [phaselock_time, pairsynchmat, movmat] = stead2phaselock(filemat, pairmat, bslvec, plotflag);    if nargin < 2, plotflag = [], endfor fileindex = 1 : size(filemat,1);    	FilePath = filemat(fileindex,:);   			[rawmat,File,Path,FilePath,NTrialAvgVec,StdChanTimeMat,...		SampRate,AvgRef,Version,MedMedRawVec,MedMedAvgVec,EegMegStatus,NChanExtra]= ReadAvgFile(FilePath);	filtmat = rawmat;		%============================================================	% 2. bsl correction	%===========================================================		rawmat = bslcorr(rawmat, bslvec); 		%===========================================================	% 3. moving window procedure depending on stim frequency	%===========================================================	disp('moving window procedure')		winmatsum = zeros(size(rawmat,1),125);	    fouriersum = zeros(1, size(rawmat,1));        interdiffsum = zeros(size(pairmat,1), 1);         	    if plotflag, h = figure, pause, end    	index = 1; 	for winshift = 0 : 25 : 1375 ; % shift nach baseline 101-1600        		winmatsum = (winmatsum + regressionMAT(datamat(:,[latsp+winshift:latsp+winshift+124])));                NFFT = 125; 	    NumUniquePts = ceil((NFFT+1)/2); 	    fftMat = fft(regressionMAT(datamat(:,[latsp+winshift:latsp+winshift+124]))', 128);  % transpose: channels as columns (fft columnwise)        tenHZampfft = abs(fftMat(6,:));        fouriercomp = fftMat(6,:);                 fouriersum = fouriersum + fouriercomp./tenHZampfft;                                            % inter site phase-locking                                for pairindex = 1:size(pairmat,1)                               interdiffsum(pairindex) = interdiffsum(pairindex) + (diff(fouriersum(pairmat(pairindex,:)))./abs(diff(fouriersum(pairmat(pairindex,:)))));              end                                     if plotflag           subplot(3,1,1), plot(1:4:125*4, regressionMAT(datamat(:,[latsp+winshift:latsp+winshift+124]))'), title(['sliding window starting at ' num2str((latsp+winshift)*4 -3000)  ' ms ']), ylabel('microvolts')           subplot(3,1,2), plot(1:4:125*4, winmatsum'), title(['sum of sliding windows; number of shifts:' num2str(index) ]), xlabel('time in milliseconds')           subplot(3,1,3), hold on, circle([0,0],1,200,'-'); plot([0;(imag(fouriercomp(120)./tenHZampfft(120)))], [0;(real(fouriercomp(120)./tenHZampfft(120)))]);title('phase angle of window')            pause(0.1)           movmat(index) = getframe(h)           pause       else fprintf('.')       end                index = index+1; 	end	winmat = winmatsum./56;    phaselock_time_complex = fouriersum ./56;     phaselock_pairs_complex = interdiffsum ./(56);         phaselock_time = abs(phaselock_time_complex)';         phaselock_pairs = abs(phaselock_pairs_complex);     angle_pairs = angle(phaselock_pairs_complex);        pairsynchmat = [phaselock_pairs(1:257) angle_pairs(1:257) phaselock_pairs(258:514) angle_pairs(258:514)]; 		% plot(winmat(73,:))	% title([FilePath])	% pause(5)		%===========================================================	% 3. detrending und demeaning der 5 verbleibenden zyklen:	% berechne least squares regression fuer jeden kanal	%===========================================================	%disp('demeaning of result')          	%	  for chan = 1:129;			  	%	      winmat(chan,:) = winmat(chan,:) 	%	  end	       	%===========================================================	% 5. determine amplitude and Phase using fft	%===========================================================	disp ('determining 10 Hz Phase per channel')				% for fft with amplitude scaling:		NFFT = 125; 	NumUniquePts = ceil((NFFT+1)/2); 	fftMat = fft (winmat', 128);  % transpose: channels as columns (fft columnwise)	Mag = abs(fftMat);                                                   % Amplitude berechnen	Mag = Mag*2;   		Mag(1) = Mag(1)/2;                                                    % DC trat aber nicht doppelt auf	if ~rem(NFFT,2),                                                    % Nyquist Frequenz (falls vorhanden) auch nicht doppelt        Mag(length(Mag))=Mag(length(Mag))/2;	end		Mag=Mag/NFFT;                                                         % FFT so skalieren, da? sie keine Funktion von NFFT ist		tenHZampfft = Mag(6,:);		PowerMat = real(fftMat.*conj(fftMat)/125);		%tenHZampfft = sqrt(PowerMat(6,:));		PhaseMat = atan(real(fftMat)./imag(fftMat));    	Phasevec = PhaseMat(6,:);	FourierCompVec = fftMat(6,:);	    real_part = real(FourierCompVec);     imag_part = imag(FourierCompVec); 		%===========================================================	% 6. bestimmung der mittleren Amplitude mit diffferenz(max-min)	%===========================================================		Phasevec = Phasevec';	tenHZampfft = tenHZampfft';	% 	SaveAvgFile([FilePath '.amp' ],tenHZampfft,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus)%         % 	%SaveAvgFile([FilePath '.win' ],winmat,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus)%         % 	SaveAvgFile([FilePath '.pha' ],Phasevec,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus)%     %     SaveAvgFile([FilePath '.Tlock' ],phaselock_time,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus); %     %     SaveAvgFile([FilePath '.sync' ],pairsynchmat,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus);%     %     SaveAvgFile([FilePath '.real' ],real_part,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus);%     %     SaveAvgFile([FilePath '.imag' ],imag_part,NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus);%     enda = toc; disp([num2str(a/60) ' minutes for this subject'])