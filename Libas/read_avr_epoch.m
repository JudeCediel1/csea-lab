function [AvgWaPower, SumPower] = read_avr_epoch(filename, Nepochs, nr_timepoints);if nargin==0,		% No name specified	[name, pathname] = uigetfile('*', 'Choose a BESA-*.avr-file!');	filename = sprintf('%s%s', pathname, name);end;fid = fopen(filename, 'r');line = fgetl(fid);[dummy, remainder] = strtok(line);if strcmp(dummy, 'Npts=')==0, disp('1This is not an *.avr-header!!!'); fclose(fid); return; end;[dummy, remainder] = strtok(remainder);			% Number of timepoints (number of columns)nr_timepoints_ges = str2num(dummy);[dummy, remainder] = strtok(remainder);if strcmp(dummy, 'TSB=')==0, disp('2This is not an *.avr-header!!!'); fclose(fid); return; end;[dummy, remainder] = strtok(remainder);					% Begin of latency rangeoffset = str2num(dummy)[dummy, remainder] = strtok(remainder);if strcmp(dummy, 'DI=')==0, disp('3This is not an *.avr-header!!!'); fclose(fid); return; end;[dummy, remainder] = strtok(remainder);				% Intervall between sample points (ms)sample_int = str2num(dummy)[dummy, remainder] = strtok(remainder);if strcmp(dummy, 'SB=')==0, disp('4This is not an *.avr-header!!!'); fclose(fid); return; end;[dummy, remainder] = strtok(remainder);					% Number of bins per microvoltnr_bins = str2num(dummy)[dummy, remainder] = strtok(remainder);if strcmp(dummy, 'SC=')==0, disp('5This is not an *.avr-header!!!'); fclose(fid); return; end;[dummy, remainder] = strtok(remainder);					% Calibration factorcalib = str2num(dummy)latencies = offset:sample_int:(nr_timepoints-1)*sample_int+offset;% compute/determine parameters for WAresize_flag = 0     % 1 : Resizefunktion an (siehe Zeile 111)						  % 0 : Resizefunktion aus	                    % ueberfluessige Werte durch Zeropadding fliegen raus und nur jeder                     % <resize_step> .te Wert wird gespeichertresize_step = 1     % Schrittweite der Resizefunktion						  % (1 : jeder Wert wird geschrieben)                    % ACHTUNG: dies muss natuerlich bei der Achsenbeschriftung                    % mit make_xy_wa beruecksichtigt werden                    Phase_lock_flag = 0 % 1 : Phaselockfaktor Datei wird erzeugt						  % 0 : Phaselockfaktor Datei wird nicht erzeugtNTrials = Nepochs; electrodes = [1:148];   %Electrodes to analyze % parameters for freq resolutionSampRate = 1000 / sample_intdelta_f0 = 1f0_start = 8f0_end = 90% end parameters / start data / waveletfor epoch = 1: Nepochsepoch_data = fscanf(fid, '%f', [nr_timepoints, inf]);epoch_data = epoch_data';NPointsold = nr_timepoints;% Npoints runden auf naechste 2erpotenz  matsize = 2;  potsize = 2;  while matsize < NPointsold;  potsize = potsize + 1;  matsize = 2^potsize;  end  NPointsNew = matsize;wavelet = gener_Wav(NPointsNew, delta_f0, f0_start, f0_end);  disp('size of waveletMatrix')  disp(size(wavelet))  disp (' frequency step for delta_f0 = 1 is ')  disp(SampRate/NPointsNew)  % Berechnung der WA  SumPower = [];  AvgWaPower = [];      %schleife ueber KANAELE  for e  = 1 :  size(electrodes,2);     channel = electrodes(e);      % schleife ueber TRIALS         fprintf('wa of channel %g , trial %g of %g   ',channel, trial, NTrials)		 % daten padden bis N = NPoints = 2^X       % dazu: daten auf jeden fall als ZEILENVEKTOR !!!!      data = epoch_data(channel, :);      			a = size(data);               if a (1) ~= 1                  data = data';               end                      data_pad = [data'; zeros(NPointsNew-NPointsold,1)];                     [WAPower, WARayleigh]=wa_new(data_pad, wavelet, NPointsNew, delta_f0, f0_start, f0_end,NPointsold);		                     if epoch == 1		 SumPower = WAPower;       SumRayleigh = WARayleigh;       else        SumPower = SumPower + WAPower;       SumRayleigh = SumRayleigh+WARayleigh;         	 end           end     disp('writing channel to Average Matrix')          if resize_flag == 1        % !!!!!!!!!!!!!!!! RESIZE FUNKTION !!!!!!!!!!!!!!!!!!!       % damit die matrix nicht zu gross wird       % !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!       disp('resizing matrix')       SumPower = SumPower(:, [1:resize_step:NPointsold]);       SumRayleigh = SumRayleigh(:, [1:resize_step:NPointsold]);     end;          AvgWaPower(e,:,:) = SumPower./NTrials;     PhasLockfac(e,:,:) = abs(SumRayleigh ./NTrials) ;     SumPower = [];     SumRayleigh = [];          end     disp('saving to disk:   ')   disp([file_name '.wa.mat'])    eval([' save ' [file_name]  '.wa.mat  AvgWaPower -mat'])   if Phase_lock_flag == 1     eval([' save ' [file_name]  '.RA.mat  PhasLockfac -mat'])   end;   AvgWaPower = [];   PhasLockfac = [];	fclose ('all')	end;	fclose(fid);