function [diploc, lfdmat, data, G, invsol] = invmap_reduce_as(lfdmat1, diploc, regpar, namelist, locations, out_flag, bslvec,shellprecision,nofShells);% lfdmat = leadfield as matrix with [nrsensors by X] diploc = dipole% locations (your selected source space) as matrix with [ndipoles by 3]% locations can have different shells, or one shell, select shellprecision% of 0.0001 for spherical models and 0.5 for one shell realistic models% locations sensor locations in matrix [3 by nsensors]% data are in [elec * timepoints] formatif nargin==0,   disp(' [diploc, lfdmat, data, G, invsol] = invmap_reduce(lfdmat1, regpar, pathname, namelist, pathout, elplist, locations, from, to, out_flag); ');   return;end;from = [];to = []; elplist = []; isfrom = 1;if isempty(from),   isfrom=0;end;if ~isempty(namelist),	nr_names = length(namelist(:,1));	name = ([namelist(1,:)]);      disp('Reading data, average referencing');	%[matrix, latencies] = read_avr_bsl(name, [bslvec]);        [matrix,File,Path,FilePath,NTrialAvgVec,StdChanTimeMat,...		SampRate,AvgRef,Version,MedMedRawVec,MedMedAvgVec,EegMegStatus,NChanExtra] = ReadAvgFile(name);         [matrix] = bslcorr(matrix, bslvec);else   nr_names = 1;    matrix = ReadAvgFile(name); end;[m(1) n(1)] = size(matrix);disp(' Determine valid electrodes to be included in the following procedure');nr_electrodes = 0;for i=1:m(1),	pruef = 0;	for j=1:length(elplist),		if elplist(j)==i,			pruef = 1;			break;		end;	end;	if pruef==0,		nr_electrodes = nr_electrodes + 1;		arg(nr_electrodes) = i;	end;end;nr_electrodes; if isfrom==0, from=1; to=n(1); end;n(1) = to-from+1;data(:,1:n(1), 1) =  matrix(arg,from:to);data(:,1:n(1), 1) = avg_ref(data(:,1:n(1), 1));m(1);for i=2:nr_names,				% Reading additional files	name = ([ pathname '/' namelist(i,:)]);    [matrix,File,Path,FilePath,NTrialAvgVec,StdChanTimeMat,...		SampRate,AvgRef,Version,MedMedRawVec,MedMedAvgVec,EegMegStatus,NChanExtra] = ReadAvgFile(name);       matrix = bslcorr(matrix, bslvec);   [m(i) n(i)] = size(matrix);    if isfrom==0, from=1; to=n(i); end;   n(i) = to-from+1;   data(:,1:n(i), i) =  matrix(arg,from:to);	data(:,1:n(i), i) = avg_ref(data(:,1:n(i), i));	m(i)end;if isempty(lfdmat1),	disp('Reading leadfield matrix (lfdmat)');	lfdmat = read_matrix(1965, 129, '/Applications/MATLAB6p5p1/4tools/Libas/4data/lfd129neu.dat');	lfdmat1 = lfdmat';	size(lfdmat)end;if nr_electrodes~=length(lfdmat1(:,1)),   disp(' Resizing and reaveragereferencing leadfield matrix ');   lfdmat = lfdmat1(arg,:);   lfdmat = avg_ref(lfdmat);else   lfdmat = lfdmat1;end;disp('Computing pseudoinverse (G)');G = pinv_tikh(lfdmat, regpar);size_G = size(G); diploc = diploc';%[q, r] = when_changes_radius(diploc(1:3,:), 0.5);% [q, r] = when_changes_radius(diploc(1:3,:), 0.001);[q, r] = when_changes_radius(diploc(1:3,:), shellprecision); % Finde Quellenorte nahe den angegebenen Positionen for i=1:length(q),   for j=1:length(locations(1,:)),     if i==1,		% oberste Schicht         diff(1,:) = diploc(1,1:q(1)) - locations(1,j);            diff(2,:) = diploc(2,1:q(1)) - locations(2,j);         diff(3,:) = diploc(3,1:q(1)) - locations(3,j);         offset = 0;			% Anzahl der Punkte in oberen Schichten     else         	  diff(1,:) = diploc(1,q(i-1)+1:q(i)) - locations(1,j);            diff(2,:) = diploc(2,q(i-1)+1:q(i)) - locations(2,j);         diff(3,:) = diploc(3,q(i-1)+1:q(i)) - locations(3,j);         offset = q(i-1);       end;        	  diff = norm_col(diff);	  [Y,I] = min(diff);     elem(i,j) = offset+I;				% Indizes der nahesten Quellenraumelemente  	  koor(1:3,i,j) = diploc(1:3,elem(i,j)); 	  koor(4,i,j) = Y;     clear diff;   end;end;j = nofShells; disp('Computing and writing  inverse solutions (invsol)');   dim = 3;	for i=1:nr_names,      		if strcmp(out_flag, 'abs'),         	inv =  inv_recon(G, data(1:nr_electrodes,1:n(i),i), dim);	         	% Modulo (Intensity map)      		end;     		 if strcmp(out_flag, 'rad'),      		inv = G(3:3:size(lfdmat1,2),:)*data(1:nr_electrodes,1:n(i),i);			% Radial component            inv = inv .*100;       		end;      for j=1:j,         if strcmp(out_flag, 'abs'),				filename = [namelist(i,:) '.MN' num2str(j)];      	end;      	if strcmp(out_flag, 'rad'),				filename = [namelist(i,:) '.rad' num2str(j)];      	end;			disp(filename);	      fid = fopen(filename, 'w');	      if j==1,	         invsol(:,1:n(i),i) = inv;             size_inv_2 = size(inv)			         % SaveAvgFile(FilePath,AvgMat,NTrialAvgVec,StdChanTimeMat,SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus,NChanExtra);              % write_avr(, filename, 1, 1);			 SaveAvgFile(filename,inv(elem(1,:),1:n(i)),NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus); 			                        size_1 = size(inv(elem(1,:),1:n(i)));             	      elseif j==length(q),	         invsol(:,1:n(i),i) = inv;	         SaveAvgFile(filename, inv(elem(j,:), 1:n(i)),NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus);	      else	         invsol(:,1:n(i),i) = inv;	         SaveAvgFile(filename, inv(elem(j,:), 1:n(i)),NTrialAvgVec,[],SampRate,MedMedRawVec,MedMedAvgVec,EegMegStatus);         end;		end;			% j   end;		% i   