% Program Data_IO_2 (Specified structure array for BTi-header and -data)% ------------------------------------------------------------------------------------% ------ Program for data import into the MATLAB workstation -------------------------% ------------------------------------------------------------------------------------% Patricia Schörken% Last update: 09.05.1999% ----------- Default values ---------------------------------------------------------n=0;index=1;chan_int_index=[1];chan_float_index=[4 5 6 7 8 9];chan_string_index=[2 3];glob_int_index=[1 2 7 8 9 10];glob_float_index=[5 6];glob_string_index=[3 4];chan_header_jump=9;glob_header_jump= 10;% ----------- Free variable parameters (Fvp)------------------------------------------x=[];data_type=[];% ------------------------------------------------------------------------------------% --------------------------ACCESS HEADER INFORMATION --------------------------------% ------------------------------------------------------------------------------------% ----- Load BTI header (ascii) into the workspace -----------------------------------header_filename = input...   ('Enter filename of the header: ','s');fid=fopen(header_filename,'rt');% ----- Define temporary structure array, containing global header-information -------  Temp_Header=struct('temp_header_data',x);while feof(fid)==0   x=fgets(fid);   if length(x)==1      disp('Leerzeile')   else       Temp_Header=setfield(Temp_Header,{index},'temp_header_data',x);      index=index+1;   endendfclose(fid);% ----- Partial conversion of the dataformat: string --> numeric ---------------------for i=1:length(glob_int_index)   x=[Temp_Header(glob_int_index(i)).temp_header_data];   Temp_Header=setfield(Temp_Header,{glob_int_index(i)},'temp_header_data',str2num(x));endfor i=1:length(glob_float_index)  x=[Temp_Header(glob_float_index(i)).temp_header_data];  Temp_Header=setfield(Temp_Header,{glob_float_index(i)},'temp_header_data',str2num(x));endfor i=1:length(glob_string_index)  x=[Temp_Header(glob_string_index(i)).temp_header_data];  Temp_Header=setfield(Temp_Header,{glob_string_index(i)},'temp_header_data',x);end[total_channels]=deal(Temp_Header(glob_header_jump).temp_header_data);while n<total_channels   for j=1:length(chan_int_index)       x=Temp_Header(chan_int_index(j)+...          n*chan_header_jump+glob_header_jump).temp_header_data(:,:);       Temp_Header=setfield(Temp_Header,{chan_int_index(j)+...             n*chan_header_jump+glob_header_jump},'temp_header_data',str2num(x));   end   for j=1:length(chan_float_index)      x=Temp_Header(chan_float_index(j)+...         n*chan_header_jump+glob_header_jump).temp_header_data(:,:);      Temp_Header=setfield(Temp_Header,{chan_float_index(j)+...         n*chan_header_jump+glob_header_jump},'temp_header_data',str2num(x));   end   for j=1:length(chan_string_index)     x=Temp_Header(chan_string_index(j)+...        n*chan_header_jump+glob_header_jump).temp_header_data(:,:);      Temp_Header=setfield(Temp_Header,{chan_string_index(j)+...            n*chan_header_jump+glob_header_jump},'temp_header_data',x);   end   n=n+1;end% ----- Define structure array, containing global- and channel- header information ---  Header=struct('global',struct('header_format',x,'data_format',x,...   'file_description',x,'time_stamp',x,'epoch_begin_latency',x,...   'sample_period',x,'total_epochs',x,'input_epochs',x,'pts_in_epochs',x,...   'total_channels',x),'channel',struct('data_type',x,'channel_name',x,...   'yaxis_label',x,'ymin',x,'ymax',x,'conv_factor',x,'shift_factor',x,...   'position',x,'vector',x));% ----- Set string index in order to access structure array --------------------------global_index=char('header_format','data_format','file_description','time_stamp',...      'epoch_begin_latency','sample_period','total_epochs','input_epochs',...      'pts_in_epochs','total_channels');channel_index=char('data_type','channel_name','yaxis_label','ymin','ymax','conv_factor',...      'shift_factor','position','vector');% ----- Assign array values ----------------------------------------------------------n=0;for i=1:glob_header_jump   x=deal(Temp_Header(i).temp_header_data);   Header.global=setfield(Header.global,global_index(i,:),x);endwhile n<total_channels   for i=1:chan_header_jump      x=deal(Temp_Header(i+n*chan_header_jump+glob_header_jump).temp_header_data);      Header.channel=setfield(Header.channel,{n+1},channel_index(i,:),x);   end   n=n+1;end% ------------------------------------------------------------------------------------% --------------------------ACCESS DATA ----------------------------------------------% ------------------------------------------------------------------------------------conv_factor=[];shift_factor=[];data=[];data_type=[];skip=[];start_time=[];end_time=[];pos=[];N=[];% ----- Load BTI data (binary) into the workspace ------------------------------------fid=0;data_filename = input...   ('Enter filename of the data: ','s');[fid,message] = fopen...   (data_filename,'r','b');             % Open data file;                                         % fid =File identifier to access the fileif fid==-1   disp(message);end% ----- read data latency- or row-wise -----------------------------------------------epoch_number=Header.global.total_epochs;epoch_length=Header.global.pts_in_epochs;total_channels=Header.global.total_channels;data_format=Header.global.data_format;data_format_labels ={'short','long','float','int'};data_format_index_labels=[2 4 4 4];data_format_index=data_format_index_labels(data_format);data_format=char(data_format_labels(data_format))for i=1:total_channels   data_type=[data_type Header.channel(i).data_type];enddisp(['Number of epochs: ',num2str(epoch_number)]);disp(['Epoch length: ',num2str(epoch_length)]);% ----- Select time range ------------------------------------------------------------switch epoch_number case 1   start_time=str2num(input('Select start latency: (e.g.: 1...n) ','s'));   end_time=str2num(input('Select end latency: (e.g.: 1...n) ','s'));   temp_epoch_length=end_time-(start_time-1);otherwise    epoch_select=str2num(input('Select epoch no.: (e.g.: 1...n) ','s'));end% ---- Select channels ---------------------------------------------------------------chan_prefer=(input('Select channels: group=g, single channels=s : ','s'));switch chan_prefercase 'g'   chan_group=str2num(input('Select channelgroup: All=1, MEG=2, EEG=3, MEG/EEG=4 Reference=5, Copied channels:=6 ','s'));      switch chan_group   case 1      skip=fread(fid,[total_channels (start_time-1)],data_format);       data=fread(fid,[total_channels (end_time-(start_time-1))],data_format);            for i=1:total_channels         conv_factor=[conv_factor; Header.channel(i).conv_factor];         shift_factor=[shift_factor; Header.channel(i).shift_factor];      end            [L,N]=size(data);      data=data.*(repmat(conv_factor,[1,N]))-...         (repmat(shift_factor,[1,N]));         case 2      pos=find(data_type==1);      N=length(pos);      channel_labels=char(Header.channel(find(data_type==1)).channel_name);      for i=1:temp_epoch_length         for j=1:N            fseek(fid,(pos(j)-1)*data_format_index,-1);            data(i,j)=fread(fid,1,data_format);         end         skip=fseek(fid,total_channels*4,-1);         pos=pos+total_channels;      end               case 3      pos=find(data_type==2);      N=length(pos);      channel_labels=char(Header.channel(find(data_type==2)).channel_name);      for i=1:temp_epoch_length         for j=1:N            fseek(fid,(pos(j)-1)*data_format_index,-1);            data(i,j)=fread(fid,1,data_format);         end         skip=fseek(fid,total_channels*4,-1);         pos=pos+total_channels;      end   case 4      pos=find(data_type==3);      N=length(pos);      channel_labels=char(Header.channel(find(data_type==3)).channel_name);      for i=1:temp_epoch_length         for j=1:N            fseek(fid,(pos(j)-1)*data_format_index,-1);            data(i,j)=fread(fid,1,data_format);         end         skip=fseek(fid,total_channels*4,-1);         pos=pos+total_channels;      end         otherwise      pos=find(data_type==7);      N=length(pos);      channel_labels=char(Header.channel(find(data_type==7)).channel_name);      for i=1:temp_epoch_length         for j=1:N            fseek(fid,(pos(j)-1)*data_format_index,-1);            data(i,j)=fread(fid,1,data_format);         end         skip=fseek(fid,total_channels*4,-1);         pos=pos+total_channels;      end   end      case 's'   channels=[];   x=[];   single_chan=(input('Select single channels (e.g.: A1...A2) : ','s'));   single_chan=[single_chan,' '];   l=length(single_chan);      for i=1:l      if strcmp(' ',single_chan(i))~=1           x=[x single_chan(i)];      else         channels=[channels; x];         x=[];      end   end   endfclose(fid);% ----- Output: Printing global header or header for selected channels ---------------% ----- Output: Printing data latency- or channelwise --------------------------------% ------------------------------------------------------------------------------------% ------------------------------------- END ------------------------------------------% ------------------------------------------------------------------------------------% Ergänzungen:% find(strcmp(data_format_labels,'integer')==1)% x=char(Header.channel.channel_name);