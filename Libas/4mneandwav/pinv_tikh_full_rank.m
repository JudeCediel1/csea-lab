% Computes pseudoinverse with Tikhonov-Phillips regulariztion for matrices whose% conditioning can be deduced from their dimensions, i.e. m<n => purely underdetermined% m>n => purely overdetermined,  m=n => nonsingular% Inversion is applied on Gram-matrices (numerically not optimal, but faster (?),% and, especially if only few rows of the pseudoinverse are demanded, memory saving% A: Matrix to be inverted (constraints see above)% lambda (optional): Tikhonov-Phillips regularization parameter (Gram(A)+lambda*I is inverted)% rows() (optional): Vector with rows of pseudoinverse G which shall be output% If A does not have either full row rank or full columns rank, pinv_tikh should not be applied% with lambda = 0.0 (if at all)!!!% OH 29.10.97function  G = pinv_tikh(A, lambda, rows);[m n] = size(A);p = min(m,n);if (m<n),			% Purely underdetermined problem   	if (nargin==1) | (nargin==2),		% if no special rows selected			G = A'*inv(A*A'+lambda*eye(p,p));		else			C = inv(A*A'+lambda*eye(p,p));		% inverting Gram matrix			G = A(:,rows)'*C;		% Selecting rows for output      end;end;if (m>n),			% Purely overdetermined problem   if (nargin==1) | (nargin==2),			G = inv(A'*A+lambda*eye(p,p))*A';			else			C = inv(A'*A+lambda*eye(p,p));			G = C(rows,:)*A';      end;	end;if (m==n)			% Well-determined problem		if (nargin==1) | (nargin==2),			G = inv(A+lambda*eye(p,p));			else			C = inv(A+lambda*eye(p,p));			G = C(rows,:);      end;end;clear C;