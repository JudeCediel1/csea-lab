  function [data, correl, rmsvec, paths, names] = succ_correl_bat(paths, names, format, elplist, from, to, mst_flag, plot_flag, nameout);if nargin==0,   disp(' [data, correl, rms, paths, names] = succ_correl_bat(paths, names, format, elplist, from, to, mst_flag, plot_flag, nameout); ');   return;end;if isempty(names),   if strcmp(format, 'avr'), ending = '*.avr'; end;	if strcmp(format, 'mfxtxt'), ending = '*.asc'; end;   [namelist, names, paths] = read_filelist(ending);   nr_names = length(namelist(:,1));else   nr_names = length(names(:,1));   for i=1:nr_names,      namelist(i,1:length(deblank(names(i,:)))+length(deblank(paths(i,:)))) = sprintf('%s%s', deblank(paths(i,:)), deblank(names(i,:)));   end;end;namelist[data, m, n, latencies] = read_data(namelist, elplist, format);colours = char('r', 'b', 'g', 'm', 'c', 'y', 'b', 'w');if nr_names>length(colours),	disp('Not enough colours for all files! (succ_correl_bat.m)');end;if strcmp(plot_flag, 'subplot'),	s = sqrt(nr_names);	% Find appropriate dimensions for the subplot matrix	if round(s)==s		plotrows = round(s);		plotcols = round(s);	else		for i=1:ceil(s),			if i*ceil(s)>=nr_names,				plotrows = ceil(s);				plotcols = i;				break; 			end;      end;   end;end;if ( strcmp(mst_flag, 'ang') | strcmp(mst_flag, 'rmsang')  | strcmp(mst_flag, 'angrms') ),   disp('Computing angles');   if isempty(from), from=2; end;   for i=1:nr_names,      if isempty(to), to=n(i); end;		correl(:,i) = succ_corr(data(:,:,i), from, to)';	end;   disp('Plotting angles');   figure;      title('Winkel zwischen den Topographien aufeinanderfolgender Zeitpunkte');   for i=1:nr_names,      if strcmp(plot_flag, 'subplot'),         subplot(plotrows, plotcols, i); hold on;         grid;         title(names(i,:));        	xlabel('Latenz');         ylabel('Winkel');        	axis([latencies(i,from)  latencies(i,to)  0  max(max(correl))]);	   end;		if i<length(colours),			c = colours(i);		else			c = 'b';		end;		plot(latencies(1,from:to), correl(:,i), c); hold on;   end;   if ~strcmp(plot_flag, 'subplot'),       grid;      legend(names(:,1:5), 1);  hold on;     	xlabel('Latenz');      ylabel('Winkel');	 	axis([latencies(1,from)  latencies(1,to)  0  max(max(correl))]);   end;   if ~isempty(nameout),      nametmp = sprintf('%s.ang', nameout);      write_matrix(correl, nametmp);   end;end;if ( strcmp(mst_flag, 'rms') | strcmp(mst_flag, 'rmsang')  | strcmp(mst_flag, 'angrms') ),   disp('Computing root means squares');   if isempty(from), from=1; end;   for i=1:nr_names,      if isempty(to), to=n(i); end;		rmsvec(:,i) = rms(data(:,:,i), from, to)';	end;   disp('Plotting root mean squares');   figure;   title('Root Mean Squares (RMS)');	   grid;   for i=1:nr_names,      if strcmp(plot_flag, 'subplot'),         subplot(plotrows, plotcols, i); hold on;         grid;	      title(names(i,:));     		xlabel('Latenz');   	   ylabel('RMS');	     	axis([latencies(i,from)  latencies(i,to)  0  max(max(rmsvec))]);	   end;		if i<length(colours),			c = colours(i);		else			c = 'b';		end;		plot(latencies(1,from:to), rmsvec(:,i), c); hold on;   end;   if ~strcmp(plot_flag, 'subplot'),       grid;		legend(names(:,1:5), 1);  hold on;		axis([latencies(1,from)  latencies(1,to)  0  max(max(rmsvec))]);		xlabel('Latenz');      ylabel('RMS');   end;   if ~isempty(nameout),      nametmp = sprintf('%s.rms', nameout);      write_matrix(rmsvec, nametmp);   end;end;   