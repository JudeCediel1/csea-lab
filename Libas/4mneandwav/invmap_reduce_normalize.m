% Compute minimum norm solutions on different shells of 3D source space, output for different shells separately, output only for specified locations possible% Solutions are normalized by their euclidian lengths% lfdmat1: Leadfield matrix for given source space and sensor/electrode configuration% dim: Number of dipole components, e.g. 3 for EEG (x,y,z), 2 for MEG (tangential)% method: 'EEG' or 'MEG'% regpar: Regularization parameter for Tikhonov-Regularization (e.g. chosen by adjusting residual variance)% paths, names: list of paths and names for datafiles to be analyzed, if paths,names=='': File list can be created via a menu (choose files, then press 'Abbrechen')% format: input data format, 'avr' for BESA-*.avr-files, 'mfxtxt' for BTI-MFX-ASCII-output (assuming first row elements to be latency values!)% pathout: Pathname for output of results% elplist: Channel list with channels to be excluded from calculations. If lfdmat1 has as many rows as there are remaining channels, it is used as it is, otherwise% the rows specified by elplist are also excluded from lfdmat1 (and lfdmat1 is average referenced for EEG) and output as lfdmat% locations: 3*nr_points-matrix with locations for which minimum norm values shall be output (e.g. electrode positions) for each shell% from, to: Range of columns of data matrices to be analyzed, if from,to=='': All columns are included% out_flag: 'abs': for every location, the modulo of dipole strength is output (only positive values),  'rad': only radial dipole component (EEG) is output (pos. and neg. values)function [diploc, lfdmat, data, G, invsol, paths, names] = invmap_reduce_normalize(lfdmat1, dim, method, regpar, paths, names, format, pathout, elplist, locations, from, to, out_flag);if nargin==0,   disp(' [diploc, lfdmat, data, G, invsol, paths, names] = invmap_reduce_normalize(lfdmat1, dim, method, regpar, paths, names, format, pathout, elplist, locations, from, to, out_flag); ');   return;end;isfrom = 1;if isempty(from),   isfrom=0;end;if strcmp(format, 'avr'), ending = '*.avr'; end;if strcmp(format, 'mfxtxt'), ending = '*.asc'; end;if isempty(names),   [namelist, names, paths] = read_filelist(ending);   nr_names = length(namelist(:,1));else   nr_names = length(names(:,1));   for i=1:nr_names,      namelist(i,1:length(deblank(names(i,:)))+length(deblank(paths(i,:)))) = sprintf('%s%s', deblank(paths(i,:)), deblank(names(i,:)));   end;end;disp('');disp(' Reading in data, average referencing');disp('');disp(namelist(1,:));if strcmp(format, 'avr'), [matrix, latencies] = read_avr(deblank(namelist(1,:))); end;if strcmp(format, 'mfxtxt'), [matrix] = 10e15*read_mfxtxt(deblank(namelist(1,:)), 'l'); end;[m(1) n(1)] = size(matrix);nr_electrodes = 0;for i=1:m(1),	pruef = 0;	for j=1:length(elplist),		if elplist(j)==i,			pruef = 1;			break;		end;	end;	if pruef==0,		nr_electrodes = nr_electrodes + 1;		arg(nr_electrodes) = i;	end;end;text = sprintf('Number of electrodes to be included in the following procedure: %d', nr_electrodes);disp(text);if isfrom==0, from=1; to=n(1); end;n(1) = to-from+1;data(:,1:n(1), 1) =  matrix(arg,from:to);if strcmp(method, 'EEG') | strcmp(method, 'eeg'),   data(:,1:n(1), 1) = avg_ref(data(:,1:n(1), 1));end;disp(m(1));for i=2:nr_names,				% Reading in additional files	disp(namelist(i,:));	if strcmp(format, 'avr'), [matrix, latencies] = read_avr(deblank(namelist(i,:))); end;	if strcmp(format, 'mfxtxt'), [matrix] = 10e15*read_mfxtxt(deblank(namelist(i,:)), 'l'); end;   [m(i) n(i)] = size(matrix);    if isfrom==0, from=1; to=n(i); end;   n(i) = to-from+1;   data(:,1:n(i), i) =  matrix(arg,from:to);   if strcmp(method, 'EEG') | strcmp(method, 'eeg'),      data(:,1:n(i), i) = avg_ref(data(:,1:n(i), i));   end;	disp(m(i));end;disp('');disp(' Reading dipole locations (diploc) ');disp('');diploc = read_matrix(1384, 4, 'c:\Matlab\analysis\elp\loc_08_02_15.sph');diploc = diploc';if isempty(lfdmat1),   disp('');   disp(' Reading leadfield matrix (lfdmat) ');   disp('');	lfdmat = read_matrix(4152, 21, 'c:\Matlab\analysis\elp\lead21_pol_08_02_01_-06.dat');	lfdmat = lfdmat';	disp(size(lfdmat));end;if nr_electrodes~=length(lfdmat1(:,1)),   disp('');   disp(' Resizing and reaveragereferencing leadfield matrix ');   disp('');   lfdmat = lfdmat1(arg,:);   if strcmp(method, 'EEG') | strcmp(method, 'eeg'),      lfdmat = avg_ref(lfdmat);   end;else   lfdmat = lfdmat1;end;    disp('');disp(' Computing pseudoinverse (G) ');disp('');G = pinv_tikh(lfdmat, regpar);disp(size(G));disp('');disp(' Computing residual variances ');disp('');nsum = 0;sumvar = 0;for i=1:nr_names,   inv = G*data(1:nr_electrodes,1:n(i),i);   variances = res_var(lfdmat, inv, data(1:nr_electrodes,1:n(i),i))';   minvar(i) = min(variances);   maxvar(i) = max(variances);   sumvar(i) = sum(variances);   nsum = nsum+n(i);   text = sprintf('Min: %f   Max: %f   Mean: %f', minvar(i), maxvar(i), sumvar(i)/n(i));   disp(text);   clear inv;end;text = sprintf('Over all:    Min: %f   Max: %f   Mean: %f', min(minvar), max(maxvar), sum(sumvar)/nsum); disp(text);[q, r] = when_changes_radius(diploc(1:3,:), 0.001);% Finde Quellenorte nahe den angegebenen Positionen for i=1:length(q),   for j=1:length(locations(1,:)),     if i==1,		% oberste Schicht         diff(1,:) = diploc(1,1:q(1)) - locations(1,j);            diff(2,:) = diploc(2,1:q(1)) - locations(2,j);         diff(3,:) = diploc(3,1:q(1)) - locations(3,j);         offset = 0;			% Anzahl der Punkte in oberen Schichten     else         	  		diff(1,:) = diploc(1,q(i-1)+1:q(i)) - locations(1,j);            diff(2,:) = diploc(2,q(i-1)+1:q(i)) - locations(2,j);         diff(3,:) = diploc(3,q(i-1)+1:q(i)) - locations(3,j);         offset = q(i-1);       end;        	  diff = norm_col(diff);	  [Y,I] = min(diff);     elem(i,j) = offset+I;				% Indizes der nahesten Quellenraumelemente     if strcmp(out_flag, 'abs'),     		for k=1:dim,        		elem_G(i,(j-1)*dim+k) = dim*elem(i,j)-dim+k;         end;     end;     if strcmp(out_flag, 'rad'),        	elem_G(i,j) = elem(i,j)*dim;     end;  	  koor(1:3,i,j) = diploc(1:3,elem(i,j)); 	  koor(4,i,j) = Y;     clear diff;  end;end;disp('Computing and writing  inverse solutions (invsol)');	offset = 0;	for i=1:nr_names,      for j=1:length(q),         size(elem_G);         invsol(offset+1:offset+length(elem_G(j,:))/dim,1:n(i),i) = normalize(inv_recon(G(elem_G(j,:),:), data(1:nr_electrodes,1:n(i),i), dim));         if strcmp(out_flag, 'abs'),				filename = sprintf('%s\\%smn%d.avr', pathout, names(i,1:6), j);      	end;      	if strcmp(out_flag, 'rad'),				filename = sprintf('%s\\%smnrad%d.avr', pathout, names(i,1:6), j);      	end;			disp(filename);	      fid = fopen(filename, 'w');         write_avr(invsol(offset+1:offset+length(elem_G(j,:))/dim,1:n(i),i), filename, 1, 1);         offset = offset+length(elem_G(j,:))/dim;		end;			% j   end;		% i      