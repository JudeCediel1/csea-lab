% Compute centres of gravity for CNV potential distributions which are given as rows in different files% COGs are computed in cartesian coordinates, but can be output in spherical coordinates (theta/phi) if an (arbitrary) argument is given% coor_flag=='sph' means output in polar coordinates, pathname contains the path with files, namelist the list of filenames to be used% elplist contains electrode number to be excluded (e.g. virtual eye channels!)function [diffl, diffa, diffs, data, n] = symm_inv_all(pathname, namelist, elplist, lfdmat);if nargin==0,   disp(' [diffl, diffa, diffs, data, n] = symm_inv_all(pathname, namelist, elplist, lfdmat); ');   return;end;max_electrodes = 29;				% Number of electrodes in the files (number of columns), also includes virtual eye electrodes!nr_names = length(namelist(:,1));disp('Reading in data, average referencing');name = sprintf('%s\\%s', pathname, namelist(1,:));disp(name);[matrix, latencies] = read_avr(name);TSB(1) = latencies(1);if length(latencies)>1, DI(1)=latencies(2)-latencies(1); else DI(1)=1; end;[m(1) n(1)] = size(matrix);disp(' Determine valid electrodes to be included in the following procedure');nr_electrodes = 0;for i=1:m(1),	pruef = 0;	for j=1:length(elplist),		if elplist(j)==i,			pruef = 1;			break;		end;	end;	if pruef==0,		nr_electrodes = nr_electrodes + 1;		arg(nr_electrodes) = i;	end;end;nr_electrodesdata(:,1:n(1), 1) =  matrix(arg,:);data(:,1:n(1), 1) = avg_ref(data(:,1:n(1), 1));for i=2:nr_names,				% Reading in additional files	name = sprintf('%s\\%s', pathname, namelist(i,:));	disp(name);   [matrix, latencies] = read_avr(name);   TSB(i) = latencies(1);   if length(latencies)>1, DI(i)=latencies(2)-latencies(1); else DI(i)=1; end;   [m(i) n(i)] = size(matrix);    data(:,1:n(i), i) =  matrix(arg,:);	data(:,1:n(i), i) = avg_ref(data(:,1:n(i), i));	m(i)end;disp('Reading in electrode locations');elpsph = read_elp('c:\Matlab\analysis\elp\26.elp');q = length(elpsph(1,:));elpxyz = elp2coor(elpsph, 1.0);elpsph(:,q+1:max_electrodes) = 0;		% "Filling in" virtual electrodes (e.g. virtual eye channels)elpxyz(:,q+1:max_electrodes) = 0;disp('Creating source space');diploc = srcspace_xyz(0.8, 0.1, -0.6);% dipsph = cart2polar(diploc);if isempty(lfdmat),	disp('Reading leadfield matrix');	lfdmat = read_matrix(6189, nr_electrodes,  'c:\Matlab\analysis\elp\lead_noeog_08_01_-06.dat');	lfdmat = lfdmat';end;disp('Computing pseudoinverse');G = pinv_tikh(lfdmat(1:nr_electrodes,:), 200);disp('Computing inverse solutions');for i=1:nr_names,	inv_sol(:, 1:n(i), i) = inv_recon(G, data(:,1:n(i),i), 3);end;disp('Computing symmetry measure for potentials');for i=1:nr_names,   diffl(1:n(i),i) = diff_inv(inv_sol(:,1:n(i),i), diploc, 1, 'lat', '');   diffa(1:n(i),i) = diff_inv(inv_sol(:,1:n(i),i), diploc, 1, 'abs', '');	diffs(1:n(i),i) = diff_inv(inv_sol(:,1:n(i),i), diploc, 1, 'sign', '');end;disp('Computing means and standard deviations');for i=1:nr_names,   meansl(i) = mean(diffl(1:n(i),i));   stdsl(i) = std(diffl(1:n(i),i));   meansa(i) = mean(diffa(1:n(i),i));   stdsa(i) = std(diffa(1:n(i),i));   meanss(i) = mean(diffs(1:n(i),i));   stdss(i) = std(diffs(1:n(i),i));end;colours = char('r', 'b', 'g', 'm', 'c', 'y', 'w', 'k');if nr_names>length(colours),	disp('Not enough colours for all files! (symmetry)');end;disp(' Write values to file ');for i=1:nr_names,   filename = sprintf('c:\\data\\tmp\\%slatind.dat', namelist(i,1:3))   write_matrix(diffl(1:n(i),i), filename);end;disp('Plotting');clf;	for i=1:nr_names,		if i<length(colours),         c = sprintf('%s:', colours(i));		else         c = 'k:';		end;		plot(diffl(1:n(i),i), c); hold on;	end;   legend(namelist(:,1:3), 1);  hold on;   for i=1:nr_names,		if i<length(colours),         c = sprintf('%so', colours(i));		else         c = 'ko';		end;		errorbar(i, meansl(i), stdsl(i), c); hold on;	end;   xlabel('Subjects'); ylabel('Symmetry measure');   title('Lateralisations-Index');      figure(gcf+1);	for i=1:nr_names,		if i<length(colours),         c = sprintf('%s:', colours(i));		else         c = 'k:';		end;		plot(diffa(1:n(i),i), c); hold on;	end;   for i=1:nr_names,		if i<length(colours),         c = sprintf('%so', colours(i));		else         c = 'ko';		end;		errorbar(i, meansa(i), stdsa(i), c); hold on;	end;   xlabel('Subjects'); ylabel('Symmetry measure');   title('Absolute Lateralisierung');      figure(gcf+1);   for i=1:nr_names,		if i<length(colours),         c = sprintf('%s:', colours(i));		else         c = 'k:';		end;		plot(diffs(1:n(i),i), c); hold on;	end;   for i=1:nr_names,		if i<length(colours),         c = sprintf('%so', colours(i));		else         c = 'ko';		end;		errorbar(i, meanss(i), stdss(i), c); hold on;	end;   xlabel('Subjects'); ylabel('Symmetry measure');   title('Relative Lateralisierung');