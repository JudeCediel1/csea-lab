function[AvgWaPower, SumPower]  = WA_app()% function[AvgWaPower, SumPower]  = WA_app()%% Nur fuer insider%  % f0_start und f_end entsprechen NICHT Frequenzen sondern% Datenpunkten, d.h. wenn die Epoche z.B. 2048 Punkte lang ist% (nach dem Zeropadding) und eine Samplingrate von 500 Hz verwendet wurde% ergibt sich eine Frequenzaufloesung von fa = 500/2048 = 0.244.% fa * fO_start ergibt die tatsaechliche Startfrequenz% fa * f0_end ergibt die tatsaechliche Endfrequenz% Die Wavelets werden nicht fuer jeden Punkt sondern fuer jeden% delta_f0ten Punkt berechnet, um Speicher zu sparen%% Ergibt sich also z.B. ein Wavelet mit 49 Zeilen, f0_start bei 10% und F0_end von 250 und delta_f0 von 5 und 500 Hz ergibt sich:%% 500/2048 = 0.244;% 10 * 0.244  = 2.44 Hz Startfrequenz% 250 * 0.244 = 61 Hz Endfrequenz% 2.44 : 5*0.244 : 61 = 49 Zeilen im Wavelet%% Paramenter sind im Sourcecode einzutragen%% (c) Keil & Gruber, 1999%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%files = [];struc = dir('H:\');for index = 3 : size(struc,1);   files(index, :) = getfield(struc,{index}, 'name');endfiles = char(files(57:length(files(:,1)), :))%files = ['simu_visu16_jitter25.app.MN3';'simu_visu16_jitter25.app.MN1';'simu_visu16_jitter25.app.MN2';'simu_visu16_jitter25.app.csd'];FilePath = ['H:\']disp('electrodes to analyze');electrodes = [1:129];   %Electrodes to analyzedelta_f0 = 1f0_start = 8f0_end = 90%Schleife ueber filesfor nf = 1 : size(files,1)  file_name = [FilePath files(nf,:)]  save_name = [files(nf, :)]    % insert compute ERP  sumdata = [];  [data,Version,LHeader,ScaleBins,NChan,NPointsold,NTrials,SampRate,ch_AvgRef]=ReadAppData_emolat(file_name);  for erptrial = 1 : NTrials     [data]=ReadAppData_emolat(file_name, erptrial);     if erptrial == 1        sumdata = data;     else        sumdata = data + sumdata;     end       end  erpdata = sumdata ./ NTrials;        [data,Version,LHeader,ScaleBins,NChan,NPointsold,NTrials,SampRate,ch_AvgRef]=ReadAppData_emolat(file_name);  disp('size of data matrix')  disp(size(data))NPointsold = 512	  % Npoints runden auf naechste 2erpotenz  matsize = 2;  potsize = 2;  while matsize < NPointsold;  potsize = potsize + 1;  matsize = 2^potsize;  end  NPointsNew = matsize;  wavelet = gener_Wav(NPointsNew, delta_f0, f0_start, f0_end);  disp('size of waveletMatrix')  disp(size(wavelet))  disp (' frequency step for delta_f0 = 1 is ')  disp(SampRate/NPointsNew)      % Berechnung der WA  SumPower = [];  AvgWaPower = [];      %schleife ueber KANAELE  for e  = 1 :  size(electrodes,2);     channel = electrodes(e);      % schleife ueber TRIALS	  for trial = 1 : NTrials;         fprintf('wa of channel %g , trial %g of %g   ',channel, trial, NTrials)		 [data]=ReadAppData_emolat(file_name, trial, channel);       data = data - erpdata(channel, :);                % insert for subtraction of ERP              % daten padden bis N = NPoints = 2^X       % dazu: daten auf jeden fall als ZEILENVEKTOR !!!!            			a = size(data);               if a (1) ~= 1                  data = data';               end                      data_pad = [data'; zeros(NPointsNew-NPointsold,1)];		 [WAPower, WARayleigh]=wa_new(data_pad, wavelet, NPointsNew, delta_f0, f0_start, f0_end, NPointsold);		 if trial == 1		 SumPower = WAPower;		 else 		 SumPower = SumPower + WAPower;		 end           end     disp('writing channel to Average Matrix')          AvgWaPower(e,:,:) = SumPower./NTrials;     SumPower = [];   end   disp('saving to disk:   ')   disp([file_name '.wa.mat'])    eval([' save F:\emolat\' [save_name]  '.wa.mat  AvgWaPower -mat'])   AvgWaPower = [];	fclose ('all')	end;	