% Minimum-Norm Interpolation von individuellen Sensoren auf Referenzsystem über Minimum-Lösung% sensor_name, cos_name: Filenames for individual sensors and centre of spheres% ref_sensor, ref_cos: Reference sensor geometry and centre of sphere on which data shall be interpolated% lfdmat_ref (optional): Leadfield matrix for reference sensor geometry% filelist: Names of filenames for given individual sensor geometry which shall be interpolated% regpar: Regularisation parameter for computation of pseudoinverse% off_space: Maximal coordinates for dipole positions which shall be included for forward computations (artefact rejection possible)function [lfdmat_ref] = interpolate_MEG(sensor_name, cos_name, ref_sensor, ref_cos, lfdmat_ref, off_space, filelist, regpar, off_channels);if nargin==0,   disp(' [lfdmat_ref] = interpolate_MEG(sensor_name, cos_name, ref_sensor, ref_cos, lfdmat_ref, off_space, filelist, regpar, off_channels); ');   return;end;disp('Read dipole locations');dipole_locations = read_matrix(655, 4, 'd:\data\graphem_meg\dipoles\dipoles.dat')';		% Reading dipole locationsdisp('Read sensors');[sensors, name, pathname, filename] = read_pmg(sensor_name);		% Read sensors from *.pmg-filesensors(1:3,:) = sensors(1:3,:)*100;				% Convert in cmdisp('Read centre of sphere');[centre_of_sphere]=dlmread(cos_name, ',')			% Read centre of sphere (x y z)centre_of_sphere = 100*centre_of_sphere;			% Convert in cmcount_offs = 0;if ~isempty(off_space),   disp(' Determine offspace ');   dips = dipole_locations(1:3,:);   for i=1:length(dipole_locations(1,:)),      if dips(1,i)<off_space(1) | dips(1,i)>off_space(2)  |  dips(2,i)<off_space(3) | dips(2,i)>off_space(4)  |  dips(3,i)<off_space(5) | dips(3,i)>off_space(6),         count_offs = count_offs + 1;         out_elem(2*count_offs-1) = 2*i-1;		% Only MEG: Two dipoles per location assumed!!!         out_elem(2*count_offs) = 2*i;      end;   end;   text = sprintf('%d elements excluded from forward computation!\n', count_offs);   disp(text);end;disp('Compute leadfield matrix');[lfdmat, orientations, v] = compute_lfdmat(dipole_locations(1:3,:), sensors, 'MEG', 'sph', centre_of_sphere);	% Compute leadfield matrix (forward solutions)valid_sensors = 1:148;if ~isempty(off_channels),   valid_sensors = reduce_columns(off_channels, valid_sensors);end;disp('Compute pseudoinverse');G = pinv_tikh(lfdmat(valid_sensors,:), regpar);if count_offs>0,	lfdmat(:,out_elem) = 0;				% Remove columns corresponding to offspace from leadfield   G(out_elem,:) = 0;					% Remove columns corresponding to offspace from pseudoinverseend;disp(' Computing data resolution matrix ');data_resolution_matrix = lfdmat*G;		% Compute data resolution matrix to test how accurate original data would be projected on original sensor geometryif isempty(lfdmat_ref) & ~isempty(ref_sensor),	   disp('Compute leadfield matrix for reference sensor geometry');   lfdmat_ref = compute_lfdmat(dipole_locations(1:3,:), ref_sensor, 'MEG', 'sph', ref_cos);end;if count_offs>0, lfdmat_ref(:,out_elem) = 0; end;		% Remove columns corresponding to offspace from reference leadfieldisp('Compute transformation matrix');if ~isempty(ref_sensor),   transform_matrix = lfdmat_ref*G;else,   transform_matrix = lfdmat*G;end;   clear lfdmat, G;for i=1:length(filelist(:,1));   [data, m, n, latencies] = read_data(filelist(i,:), off_channels, 'avrnoref', '', '');   data_test = data_resolution_matrix*data;   diff_data = data_test(valid_sensors,:)-data;   mean_res_var = 100*mean(norm_col(diff_data, 2)./norm_col(data, 2));   text = sprintf('Mean residual variance across data sets: %f', mean_res_var);   disp(text);   text = sprintf('Transforming %s\n', filelist(i,:));   disp(text);   data_trans = transform_matrix*data;   namestem = strtok(filelist(i,:), '.');   filename = sprintf('%si.avr', namestem);   write_avr(data_trans, filename, latencies(1,1), latencies(1,2)-latencies(1,1));end;