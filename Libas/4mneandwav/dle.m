% Compute dipole localization errors (dle) for given forward solutions and inverse% forward: matrix with forward solutions as columns% floc: locations corresonding to forward solutions as columns (x,y,z)% G: (generalized) inverse% gloc: locations corresponding to rows of G as columns, number: number of rows/dim% dim: if dim>1, dim neighboured rows of G are assumed to belong to one location (i.e. % one column) of gloc% metric_flag: determines output%   'cart': Compute euclidian distance between maxima of imp.resp. and true dipole locations%   'angle': Compute angles (degrees) between maxima of imp.resp. and true dipole locations%   'ampl': Output maximum values of impulse responses% OH 05.02.98% uses dle_value_elem(), norm_col(), diag_prod()function [result, max_values] = dle(forward, floc, G, gloc, dim, metric_flag);if nargin==0,   disp(' [result, max_values] = dle(forward, floc, G, gloc, dim, metric_flag); ');   return;end;% Find maxima of impulse respondes[max_values, max_elem] = dle_value_elem(G, forward, dim);% Compute euclidian distance between maxima of imp.resp. and true dipole locationsif strcmp(metric_flag, 'cart'),   diff = floc(1:3,:)-gloc(1:3,max_elem);   result = norm_col(diff(1:3,:));end;% Compute angles (degrees) between maxima of imp.resp. and true dipole locationsif strcmp(metric_flag, 'angle'),   maxloc = gloc(1:3,max_elem);   normfloc = norm_col(floc(1:3,:));   normmaxloc = norm_col(maxloc);   correl = diagprod(floc(1:3,:)', maxloc);   correl = correl./(normfloc.*normmaxloc);	result = (180.0/pi)*abs(acos(correl));end;