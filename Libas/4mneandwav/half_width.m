% map: column vector% locations: 3*n matrixfunction [halfangle, nr_halfelem, angles, halfelem] = half_width(map, locations, tol_quot);if nargin==0,   disp(' [halfangle, angles, halfelem] = half_width(map, locations, tol_quot); ');   return;end;n = length(map);[maxmap, maxelem] = max(map);[minmap, minelem] = min(map);tol_interval = (maxmap-minmap)/tol_quot;if tol_interval<=0,   disp('Map zu gleichförmig (half_width)!!!');   return;end;diffmap = abs(map - maxmap/2);cnt = 1;for i=1:n,   if diffmap(i)<tol_interval,      halfelem(cnt) = i;      cnt = cnt+1;   end;end;nr_halfelem = length(halfelem);for i=1:nr_halfelem,   angles(i) = (180/pi)*acos(correl_columns(locations(1:3,halfelem(i)),locations(1:3,maxelem)));end;%[maxdiff,maxdiffelem] = max(norm_diff);%[mindiff,mindiffelem] = min(norm_diff);halfangle = 2.0*mean(angles);		% 2.0* weil Peak annähernd rotationssymmetrisch!!!