% tapern mit cosinus-quadrat% M2 = laenge am anfang und ende der epoche, die mit cos^2 getapert wirdfunction [WAPower, WARayleigh] = wa_new(data_pad, wavelet, NPointsNew, delta_f0, f0_start, f0_end,NPointsold);M2 = 50;squarecos1 = (cos(pi/2:(pi-pi/2)/M2:pi-(pi-pi/2)/M2)).^2;squarecos2 = (cos(0:(pi-pi/2)/M2:pi/2-(pi-pi/2)/M2)).^2;data_tap = [data_pad(1:M2).* squarecos1' ; data_pad(M2+1:length(data_pad)-M2-(NPointsNew-NPointsold)); data_pad(length(data_pad)-M2+1-(NPointsNew-NPointsold):length(data_pad)-(NPointsNew-NPointsold)).*squarecos2';data_pad(length(data_pad)-(NPointsNew-NPointsold)+1:length(data_pad))];% transform datainv_conv_real = [];data_trans = fft(data_tap, NPointsNew);thetaMATLABretrans = [];% multiplikation des Wavelet-spectrums mit dem datenspectrumindex = 1;for f0 = f0_start:delta_f0: f0_end		ProdMat(index, :) = wavelet(index, [1:NPointsNew]).*(data_trans)';	index = index + 1;	end;thetaMATLABretrans = ifft(ProdMat', NPointsNew);% disp('size of retrans matrix:')% disp(size(thetaMATLABretrans)) %thetaMATLABretrans = thetaMATLABretrans;% betrag %disp('computing .......     WApower/WARayleigh')WAPower = sqrt(real(thetaMATLABretrans).^2 + imag(thetaMATLABretrans).^2);WARayleigh = (thetaMATLABretrans ./ WAPower)';WAPower =(WAPower)';	