%function [] = find_signif_coh_mat;%aktuelle Version nach gepraech mit willi% find_signif_coh_mat% %% Die Funktion berechnet signifikante Kohaerenzen in einer Kohaerenzmatrix,% die mit ca_app bzw. ca_norm (mat files) erzeugt wurde, % nach einer Methode die an die von Rodriguez, 1999 angelehnt ist.% Es werden Signifikanzgrenzen aus der Bootstrapverteilung der .cos% Matrizen ermittelt. In den .cos files stehen Vergleiche geshuffelt ueber% Trials (d.h. auch Vps falls mit "grand mean" gerechnet wurde)% und ueber Zeitpunkte. Nicht aber ueber Elektroden%% Dabei wird auf die Zeitfenstertechnik - 1 Technik von% Rodriguez verzichtet, sondern immer nur ein ZF verwendet%% In die Ergebnismat wird 0 fuer ein nicht sign erg eingetrage%                         1 fuer sign groesser%								 -1 fuer sign kleiner als werte im schuffle file / pro zf	% (c) Keil, Gruber 1999%Anzahl der Vergleiche im .cos file, bzw. Vgl bis zu dem das prg laufen solln_vgl = 171;filenames = ['gm_r4___1.coh.n';'gm_r4_1.coh.s.n';'gm_r4___2.coh.n';'gm_r4_2.coh.s.n';'gm_r4___3.coh.n';'gm_r4_3.coh.s.n';'gm_r4___4.coh.n';'gm_r4_4.coh.s.n';             'gm_r4___5.coh.n';'gm_r4_5.coh.s.n';'gm_r4___6.coh.n';'gm_r4_6.coh.s.n';'gm_r4___7.coh.n';'gm_r4_7.coh.s.n';'gm_r4___8.coh.n';'gm_r4_8.coh.s.n'];filenames = ['gm_r4___1.coh.n';'gm_r4_1.coh.s.n']%!! immer ein 'normales' dann ein geschuffeltesfilepath  = ['Voyager:users:Gruber:coh_gestalt:']%Zeitfenster in denen verglichen werden sollt_win = [-200 0;1 200;201 400;401 600]  % !! alle gleich grosst_win = round((t_win+1500)/2);n_shuffles = 200; %200 shufflesfor cf = 1 : 2 : size(filenames,1)  % alle files durchgehen      dummy1 = [];dummy2=[];      eval(['load ' [filepath filenames(cf,:)] ' -mat']);   size(x)   xn = x;      eval(['load ' [filepath filenames(cf+1,:)] ' -mat']);   xs = x;   size(xs)         %Schleife ueber alle Vergleiche um Minis und Maxis pro Vgl zu ermitteln   shuffled_mean=[];   for c_vgl = 1 : n_vgl        %nun muss eine geshuffelte Verteilung aus ebenfalls        % 200 (oder anderer Wert)zufaellig erzeugten Mittelwerten        % aus der randomisierten Verteilung erzeugt werden               dummy4=[];dummy5=[];dummy6=[];        for i = 1 : n_shuffles          dummy4 = randperm(size(xs,2)-4);          dummy4 = dummy4 +2;          dummy4 = dummy4(1:(t_win(1,2)-t_win(1,1))); %muss der groesse des echten mittelfenster entsprechen          dummy5 = mean(xs(c_vgl,(dummy4)));          dummy6 = [dummy6 dummy5];         end;        %Nun aus der geschuffelten Verteilung pro Vgl nur Min und Max merkenc_vgl        shuffled_mean=dummy6;figurehist(shuffled_mean)error('depp')        shuffled_mean=[shuffled_mean; min(dummy6) max(dummy6)];       end;         size(shuffled_mean)           %Schleife ueber alle Vergleiche um Minis und Maxis mit Mittel des      % 'echten' Signals zu vergleichen     for c_vgl = 1 : n_vgl        %Schleife ueber Zeitfenster        for c_t = 1 : size(t_win,1)                             mittel= mean(xn(c_vgl,t_win(c_t,1):t_win(c_t,2)));                  eintrag = 0;          if mittel < shuffled_mean(c_vgl,1), eintrag = -1;end;          if mittel > shuffled_mean(c_vgl,2), eintrag =  1;end;          if c_t == 1, dummy1=[xn(c_vgl,1) xn(c_vgl,2) eintrag];end;          if c_t >  1, dummy1=[dummy1 eintrag];end;        end;        dummy2 = [dummy2;dummy1];       end;            %Bootstrapverteilungs Ergebnis sichern     x = dummy2     name = [filepath filenames(cf,:) '_erg']     eval(['save ' name '.mat x -mat']);  end;    