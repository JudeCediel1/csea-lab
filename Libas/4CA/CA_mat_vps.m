function[]  = CA_mat_vps(InMatPath, cond);% function[]  = CA_app()%% Version fuer Gestalt erweiterte 1020er und Fp1 Fp2 d.h. 23 und 9,  d.h. ohne "ASCII" Methode%% Versuch mit grandmeans ueber alle Vp bevor differenzen gebildet werden% d.h. es muss das programm ca_get_phase2 benutzt werden%% Funktion zur Berechnung einer Kohaerenzanalyse ueber Elektroden% fuer ein bestimmten Band fO%% % Die Funktion berechnet die Kohaerenzanalyse% nach Rodriguez et al., 1999%% % VOR der Koharenzanalyse wird das EP subtrahiert%% eine Datei .coh mit den Kohaerenzmassen wir erzeugt. (Vgl. Spalte 1 und 2 dieser Matrix)% ausserdem wird eine Datei .coh.s mit Kohaerenzen geschuffelt ueber trials% (fuer die spaetere Bootstrapstatistik erzeugt)%% (c) gruber 1999 v.1.1 mit grandmean basis fuer analyse% (c)  Dr. rer soc. Keil und Dipl BA Gruber, 1999%disp('patienten')                             NrTaperPoints = 20                                    AvgretransMat = [];vers_p = ['pti9801';'pti9802';'pti9803';'pti9805';'pti9807';'pti9808';'pti9809';'pti9810';'pti9812';'pti9813';'pti9815';'pti9817';'pti9818';'pti9819';'pti9820';'pti9821';'pti9823';'pti9824';'pti9825';'pti9826'];%patienten tinnitus ohne 006%vers_p = ['pti9813';'pti9815';'pti9817';'pti9818';'pti9819';'pti9820';'pti9821';'pti9823';'pti9824';'pti9825';'pti9826']%vers_p = ['kon9816';'kon9821';'kon9822';'kon9823';'kon9866';'kon9867';'kon9868';'kon9869';'kon9872';'kon9876';'kon9712';'kon9714';'kon9718';'kon9828';'kon9843';'kon9844'];%kontrollen tinnitus%vers_p = ['kon9866';'kon9867';'kon9868';'kon9869';'kon9872';'kon9876';'kon9712';'kon9714';'kon9718';'kon9828';'kon9843';'kon9844'];%kontrollen tinnitus kurz nach absturz%vers_p = ['kon9866']%bed = ['1';'5';'2';'6';'3';'7';'4';'8']% !! falls das erste zeichen die bed nicht identifiziert zeile 120 (speichern) anpassen%FilePath = ['grubi_extern:Gest_apps_r4:']  % !! in diesem Pfad muss ein Pfad \temp fuer das ERP existierendisp('sensors to analyze');% Electrodes   erweitertes 10-20er + fp1 unf fp2sensors =  [1:140]   f0 = 15; % 60/0.2441 vorsicht: haengt von epochenlaenge und Fsamp ab. siehe wa_app% !!!!!! Einschalten sofern diese Dateien noch nicht erzeugt sind% Temporaer fuer alle files das ERP berechnen und speichern% insert compute ERP%for i = 1:size(bed,1) % for j = 1:size(vers_p,1)  %  sumdata = [];  %  file_name=[FilePath vers_p(j,:) bed(i,1)]   % [data,Version,LHeader,ScaleBins,NChan,NPointsold,NTrials,SampRate,ch_AvgRef]=ReadAppData(file_name);    %for erptrial = 1 : NTrials     %  [data]=ReadAppData(file_name, erptrial);      % if erptrial == 1       %   sumdata = data;       %else        % sumdata = data + sumdata;       %end    %end    %erpdata = sumdata ./ NTrials;    %disp('size EP');    %size(sumdata)        %speichern im Pfad \temp   % tempname = [FilePath 'temp:erp_' vers_p(j,:) bed(i,1) '.mat']    %eval(['save ' tempname ' erpdata -mat'])  %end;%end; %Schleife ueber subjects und Bedingungen um temporaere phasenfiles fuer jede Elektrode zu erzeugen%for nb = 1 : size(bed,1) % nb  %file_namen = []; file_namen = []  for nf = 1 : size(vers_p,1)      file_namen = [file_namen; [vers_p(nf,:) '_' cond '.avr']];  end;  %   %   for pp = 1 : size(sensors,2)%   NPointsold=ca_getphase_mat(InMatPath,file_namen,sensors(pp), f0, NrTaperPoints, cond)%   end; %end;  % !!!! falls dieses Part weggelassen wird muessen hier die NPointsold definiert werden;NPointsold = 136%Schleife ueber Bedingungen%for nb = 1 : size(bed,1) % Schleife ueber subjects um Matrix mit filenamen fuer die aktuelle Bed zu erzeugen save_name = []; for nf = 1 : size(vers_p,1)      save_name = ['coh_' vers_p(nf,:) '_' cond '.mat' ]	 index = 0;%     %schleife ueber vergleiche  dummycount = 2;  ResMat = [];  ResMat_s = [];  for dummy1 = 1 : length(sensors)-1;              gm_name = [InMatPath ':' cond  ':complex_' num2str(sensors(dummy1))];     eval(['load ' gm_name ' -mat']);      Catvalorcomplejo_1=Catvalorcomplejo_vps(nf, :);     Catvalorcomplejo_vps = [];      for dummy2 = dummycount : length(sensors)                        gm_name = [InMatPath ':' cond  ':complex_' num2str(sensors(dummy2)) ];       eval(['load ' gm_name ' -mat']);        Catvalorcomplejo_2=Catvalorcomplejo_vps(nf,:);       Catvalorcomplejo_vps = [];               % 1. ) befehl mit sum fuer grand mean mittelung ueber VPs      	 	   gmNTrials = size(Catvalorcomplejo_2,1);       if dummy1 == 1 & dummy2 == 2         ResMat = [sensors(dummy1) sensors(dummy2) abs((Catvalorcomplejo_1(:, [1:NPointsold]) + Catvalorcomplejo_2(:, [1:NPointsold])))./ (2*gmNTrials)];    	 else         ResMat = [ResMat; sensors(dummy1) sensors(dummy2) abs((Catvalorcomplejo_1(:, [1:NPointsold]) + Catvalorcomplejo_2(:, [1:NPointsold])))./ (2*gmNTrials)];	 end	index = index+1;	 	if (index)/1000 == round((index)/1000)		fprintf('%g out of %g sensorpairs computed \n', index,((length(sensors)-1)*length(sensors)) ./ 2)		disp('')		end		       % Diesselbe Subtraktion wird nun nochmals fuer die spaetere Bootstrapstatistik       % fuer geschuffelte Trials und Zeitpunkte erzeugt%        if dummy1 == 1 & dummy2 == 2%          ResMat_s = [ sensors(dummy1)  sensors(dummy2) (abs(sum(Catvalorcomplejo_1(randperm(gmNTrials), randperm(NPointsold)) - Catvalorcomplejo_2(randperm(gmNTrials), randperm(NPointsold)))) ./ gmNTrials)];%     	 else%          ResMat_s = [ResMat_s; sensors(dummy1) sensors(dummy2) (abs(sum(Catvalorcomplejo_1(randperm(gmNTrials), randperm(NPointsold)) - Catvalorcomplejo_2(randperm(gmNTrials), randperm(NPointsold)))) ./ gmNTrials)];%     	 end                                      end;    dummycount = dummycount + 1;     end; % Schleife ueber Vergleiche         % Speichern    save_name = [InMatPath ':' save_name ] ;  eval(['save ' save_name ' ResMat -mat']);  disp (['saving file ' save_name])ResMat = [];  end  % Schleife ueber Bedingungen